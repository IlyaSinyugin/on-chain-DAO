{"version":3,"file":"TokenStreamRewriter.js","sourceRoot":"","sources":["../../src/TokenStreamRewriter.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;AAEH,wDAAwD;AAExD,8CAA2C;AAC3C,6CAAwC;AACxC,mCAAgC;AAKhC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmEG;AACH;IAiBC,YAAY,MAAmB;QAC9B,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,QAAQ,GAAG,IAAI,GAAG,EAA8B,CAAC;QACtD,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,mBAAmB,CAAC,oBAAoB,EAAE,EAAE,CAAC,CAAC;QAChE,IAAI,CAAC,uBAAuB,GAAG,IAAI,GAAG,EAAkB,CAAC;IAC1D,CAAC;IAEM,cAAc;QACpB,OAAO,IAAI,CAAC,MAAM,CAAC;IACpB,CAAC;IAQM,QAAQ,CAAC,gBAAwB,EAAE,cAAsB,mBAAmB,CAAC,oBAAoB;QACvG,IAAI,EAAE,GAAoC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QACzE,IAAK,EAAE,IAAI,IAAI,EAAG;YACjB,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,EAAE,EAAE,CAAC,KAAK,CAAC,mBAAmB,CAAC,eAAe,EAAE,gBAAgB,CAAC,CAAC,CAAC;SAChG;IACF,CAAC;IAMM,aAAa,CAAC,cAAsB,mBAAmB,CAAC,oBAAoB;QAClF,IAAI,CAAC,QAAQ,CAAC,mBAAmB,CAAC,eAAe,EAAE,WAAW,CAAC,CAAC;IACjE,CAAC;IAMM,WAAW,CAAC,YAA4B,EAAE,IAAQ,EAAE,cAAsB,mBAAmB,CAAC,oBAAoB;QACxH,IAAI,KAAa,CAAC;QAClB,IAAI,OAAO,YAAY,KAAK,QAAQ,EAAE;YACrC,KAAK,GAAG,YAAY,CAAC;SACrB;aAAM;YACN,KAAK,GAAG,YAAY,CAAC,UAAU,CAAC;SAChC;QAED,oEAAoE;QACpE,IAAI,EAAE,GAAG,IAAI,aAAa,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;QACrD,IAAI,QAAQ,GAAuB,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;QAChE,EAAE,CAAC,gBAAgB,GAAG,QAAQ,CAAC,MAAM,CAAC;QACtC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACnB,CAAC;IAMM,YAAY,CAAC,YAA4B,EAAE,IAAQ,EAAE,cAAsB,mBAAmB,CAAC,oBAAoB;QACzH,IAAI,KAAa,CAAC;QAClB,IAAI,OAAO,YAAY,KAAK,QAAQ,EAAE;YACrC,KAAK,GAAG,YAAY,CAAC;SACrB;aAAM;YACN,KAAK,GAAG,YAAY,CAAC,UAAU,CAAC;SAChC;QAED,IAAI,EAAE,GAAqB,IAAI,cAAc,CAAC,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;QACxE,IAAI,QAAQ,GAAuB,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;QAChE,EAAE,CAAC,gBAAgB,GAAG,QAAQ,CAAC,MAAM,CAAC;QACtC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACnB,CAAC;IAIM,aAAa,CAAC,KAAqB,EAAE,IAAQ;QACnD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;YAC9B,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;SACjC;aAAM;YACN,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;SACjC;IACF,CAAC;IAUM,OAAO,CAAC,IAAoB,EAAE,EAAkB,EAAE,IAAQ,EAAE,cAAsB,mBAAmB,CAAC,oBAAoB;QAChI,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;YAC7B,IAAI,GAAG,IAAI,CAAC,UAAU,CAAC;SACvB;QAED,IAAI,OAAO,EAAE,KAAK,QAAQ,EAAE;YAC3B,EAAE,GAAG,EAAE,CAAC,UAAU,CAAC;SACnB;QAED,IAAK,IAAI,GAAG,EAAE,IAAI,IAAI,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI,EAAE,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,EAAG;YAChE,MAAM,IAAI,UAAU,CAAC,2BAA2B,IAAI,KAAK,EAAE,SAAS,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG,CAAC,CAAC;SACzF;QAED,IAAI,EAAE,GAAsB,IAAI,SAAS,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,CAAC,CAAC;QACvE,IAAI,QAAQ,GAAuB,IAAI,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;QAChE,EAAE,CAAC,gBAAgB,GAAG,QAAQ,CAAC,MAAM,CAAC;QACtC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACnB,CAAC;IAcM,MAAM,CAAC,IAAoB,EAAE,EAAmB,EAAE,cAAsB,mBAAmB,CAAC,oBAAoB;QACtH,IAAI,EAAE,KAAK,SAAS,EAAE;YACrB,EAAE,GAAG,IAAI,CAAC;SACV;QAED,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;YAC7B,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,EAAY,EAAE,EAAE,EAAE,WAAW,CAAC,CAAC;SAClD;aAAM;YACN,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,EAAW,EAAE,EAAE,EAAE,WAAW,CAAC,CAAC;SACjD;IACF,CAAC;IAMS,wBAAwB,CAAC,cAAsB,mBAAmB,CAAC,oBAAoB;QAChG,IAAI,CAAC,GAAuB,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAC1E,IAAK,CAAC,IAAI,IAAI,EAAG;YAChB,OAAO,CAAC,CAAC,CAAC;SACV;QAED,OAAO,CAAC,CAAC;IACV,CAAC;IAES,wBAAwB,CAAC,WAAmB,EAAE,CAAS;QAChE,IAAI,CAAC,uBAAuB,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;IAClD,CAAC;IAES,UAAU,CAAC,IAAY;QAChC,IAAI,EAAE,GAAmC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QACjE,IAAK,EAAE,IAAI,IAAI,EAAG;YACjB,EAAE,GAAG,IAAI,CAAC,iBAAiB,CAAC,IAAI,CAAC,CAAC;SAClC;QAED,OAAO,EAAE,CAAC;IACX,CAAC;IAEO,iBAAiB,CAAC,IAAY;QACrC,IAAI,EAAE,GAAuB,EAAE,CAAC;QAChC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;QAC5B,OAAO,EAAE,CAAC;IACX,CAAC;IA2BM,OAAO,CAAC,iBAAqC,EAAE,cAAsB,mBAAmB,CAAC,oBAAoB;QACnH,IAAI,QAAkB,CAAC;QACvB,IAAI,iBAAiB,YAAY,mBAAQ,EAAE;YAC1C,QAAQ,GAAG,iBAAiB,CAAC;SAC7B;aAAM;YACN,QAAQ,GAAG,mBAAQ,CAAC,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC;SAChD;QAED,IAAI,OAAO,iBAAiB,KAAK,QAAQ,EAAE;YAC1C,WAAW,GAAG,iBAAiB,CAAC;SAChC;QAED,IAAI,QAAQ,GAAmC,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;QAC9E,IAAI,KAAK,GAAY,QAAQ,CAAC,CAAC,CAAC;QAChC,IAAI,IAAI,GAAY,QAAQ,CAAC,CAAC,CAAC;QAE/B,gCAAgC;QAChC,IAAK,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG,CAAC,EAAG;YAClC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG,CAAC,CAAC;SAC5B;QACD,IAAK,KAAK,GAAG,CAAC,EAAG;YAChB,KAAK,GAAG,CAAC,CAAC;SACV;QAED,IAAK,QAAQ,IAAI,IAAI,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAG;YAChD,OAAO,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,6BAA6B;SACnE;QAED,IAAI,GAAG,GAAa,EAAE,CAAC;QAEvB,qCAAqC;QACrC,IAAI,SAAS,GAAkC,IAAI,CAAC,+BAA+B,CAAC,QAAQ,CAAC,CAAC;QAE9F,0DAA0D;QAC1D,IAAI,CAAC,GAAY,KAAK,CAAC;QACvB,OAAQ,CAAC,IAAI,IAAI,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,IAAI,EAAG;YAC3C,IAAI,EAAE,GAAkC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YACzD,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,uCAAuC;YAC5D,IAAI,CAAC,GAAU,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAClC,IAAK,EAAE,IAAI,IAAI,EAAG;gBACjB,8CAA8C;gBAC9C,IAAK,CAAC,CAAC,IAAI,KAAK,aAAK,CAAC,GAAG,EAAG;oBAC3B,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;iBACzB;gBACD,CAAC,EAAE,CAAC,CAAC,qBAAqB;aAC1B;iBACI;gBACJ,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,6BAA6B;aAClD;SACD;QAED,uDAAuD;QACvD,iEAAiE;QACjE,8BAA8B;QAC9B,IAAK,IAAI,KAAK,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG,CAAC,EAAG;YACpC,iDAAiD;YACjD,6CAA6C;YAC7C,KAAK,IAAI,EAAE,IAAI,SAAS,CAAC,MAAM,EAAE,EAAE;gBAClC,IAAK,EAAE,CAAC,KAAK,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,GAAG,CAAC,EAAG;oBACvC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;iBAC7B;aACD;SACD;QAED,OAAO,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACrB,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAgDG;IACO,+BAA+B,CAAC,QAA6C;QACtF,2DAA2D;QAE3D,gBAAgB;QAChB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACzC,IAAI,EAAE,GAAiC,QAAQ,CAAC,CAAC,CAAC,CAAC;YACnD,IAAK,EAAE,IAAI,IAAI,EAAG;gBACjB,SAAS;aACT;YACD,IAAK,CAAC,CAAC,EAAE,YAAY,SAAS,CAAC,EAAG;gBACjC,SAAS;aACT;YACD,IAAI,GAAG,GAAc,EAAE,CAAC;YACxB,kCAAkC;YAClC,IAAI,OAAO,GAAqB,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,cAAc,EAAE,CAAC,CAAC,CAAC;YAC/E,KAAK,IAAI,GAAG,IAAI,OAAO,EAAE;gBACxB,IAAK,GAAG,CAAC,KAAK,KAAK,GAAG,CAAC,KAAK,EAAG;oBAC9B,qDAAqD;oBACrD,6CAA6C;oBAC7C,QAAQ,CAAC,GAAG,CAAC,gBAAgB,CAAC,GAAG,SAAS,CAAC;oBAC3C,GAAG,CAAC,IAAI,GAAG,GAAG,CAAC,IAAI,CAAC,QAAQ,EAAE,GAAG,CAAC,GAAG,CAAC,IAAI,IAAI,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;iBAC/E;qBACI,IAAK,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC,KAAK,IAAI,GAAG,CAAC,KAAK,IAAI,GAAG,CAAC,SAAS,EAAG;oBAC/D,iCAAiC;oBACjC,QAAQ,CAAC,GAAG,CAAC,gBAAgB,CAAC,GAAG,SAAS,CAAC;iBAC3C;aACD;YACD,2CAA2C;YAC3C,IAAI,YAAY,GAAgB,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;YAC1E,KAAK,IAAI,OAAO,IAAI,YAAY,EAAE;gBACjC,IAAK,OAAO,CAAC,KAAK,IAAI,GAAG,CAAC,KAAK,IAAI,OAAO,CAAC,SAAS,IAAI,GAAG,CAAC,SAAS,EAAG;oBACvE,kCAAkC;oBAClC,QAAQ,CAAC,OAAO,CAAC,gBAAgB,CAAC,GAAG,SAAS,CAAC;oBAC/C,SAAS;iBACT;gBACD,+CAA+C;gBAC/C,IAAI,QAAQ,GACX,OAAO,CAAC,SAAS,GAAG,GAAG,CAAC,KAAK,IAAI,OAAO,CAAC,KAAK,GAAG,GAAG,CAAC,SAAS,CAAC;gBAChE,+CAA+C;gBAC/C,uEAAuE;gBACvE,IAAK,OAAO,CAAC,IAAI,IAAI,IAAI,IAAI,GAAG,CAAC,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,EAAG;oBAC5D,0DAA0D;oBAC1D,QAAQ,CAAC,OAAO,CAAC,gBAAgB,CAAC,GAAG,SAAS,CAAC,CAAC,oBAAoB;oBACpE,GAAG,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,KAAK,CAAC,CAAC;oBAC/C,GAAG,CAAC,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,SAAS,EAAE,GAAG,CAAC,SAAS,CAAC,CAAC;oBAC3D,iCAAiC;iBACjC;qBACI,IAAK,CAAC,QAAQ,EAAG;oBACrB,MAAM,IAAI,KAAK,CAAC,4BAA4B,GAAG,0BAA0B,OAAO,EAAE,CAAC,CAAC;iBACpF;aACD;SACD;QAED,eAAe;QACf,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACzC,IAAI,EAAE,GAAiC,QAAQ,CAAC,CAAC,CAAC,CAAC;YACnD,IAAK,EAAE,IAAI,IAAI,EAAG;gBACjB,SAAS;aACT;YACD,IAAK,CAAC,CAAC,EAAE,YAAY,cAAc,CAAC,EAAG;gBACtC,SAAS;aACT;YACD,IAAI,GAAG,GAAoB,EAAE,CAAC;YAC9B,yDAAyD;YACzD,IAAI,WAAW,GAAqB,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,cAAc,EAAE,CAAC,CAAC,CAAC;YACnF,KAAK,IAAI,OAAO,IAAI,WAAW,EAAE;gBAChC,IAAK,OAAO,CAAC,KAAK,KAAK,GAAG,CAAC,KAAK,EAAG;oBAClC,IAAI,OAAO,YAAY,aAAa,EAAE;wBACrC,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;wBAClD,QAAQ,CAAC,OAAO,CAAC,gBAAgB,CAAC,GAAG,SAAS,CAAC;qBAC/C;yBACI,IAAI,OAAO,YAAY,cAAc,EAAE,EAAE,kBAAkB;wBAC/D,wDAAwD;wBACxD,8DAA8D;wBAC9D,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC;wBAClD,gCAAgC;wBAChC,QAAQ,CAAC,OAAO,CAAC,gBAAgB,CAAC,GAAG,SAAS,CAAC;qBAC/C;iBACD;aACD;YACD,uDAAuD;YACvD,IAAI,YAAY,GAAgB,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,SAAS,EAAE,CAAC,CAAC,CAAC;YAC1E,KAAK,IAAI,GAAG,IAAI,YAAY,EAAE;gBAC7B,IAAK,GAAG,CAAC,KAAK,KAAK,GAAG,CAAC,KAAK,EAAG;oBAC9B,GAAG,CAAC,IAAI,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,EAAE,GAAG,CAAC,IAAI,CAAC,CAAC;oBAC9C,QAAQ,CAAC,CAAC,CAAC,GAAG,SAAS,CAAC,CAAC,wBAAwB;oBACjD,SAAS;iBACT;gBACD,IAAK,GAAG,CAAC,KAAK,IAAI,GAAG,CAAC,KAAK,IAAI,GAAG,CAAC,KAAK,IAAI,GAAG,CAAC,SAAS,EAAG;oBAC3D,MAAM,IAAI,KAAK,CAAC,aAAa,GAAG,kCAAkC,GAAG,EAAE,CAAC,CAAC;iBACzE;aACD;SACD;QACD,iEAAiE;QACjE,IAAI,CAAC,GAAmC,IAAI,GAAG,EAA4B,CAAC;QAC5E,KAAK,IAAI,EAAE,IAAI,QAAQ,EAAE;YACxB,IAAK,EAAE,IAAI,IAAI,EAAG;gBACjB,qBAAqB;gBACrB,SAAS;aACT;YACD,IAAK,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,IAAI,EAAG;gBAC9B,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;aACnD;YACD,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;SACpB;QACD,oCAAoC;QACpC,OAAO,CAAC,CAAC;IACV,CAAC;IAES,SAAS,CAAC,CAAK,EAAE,CAAK;QAC/B,IAAI,CAAC,GAAY,EAAE,CAAC;QACpB,IAAI,CAAC,GAAY,EAAE,CAAC;QACpB,IAAK,CAAC,IAAI,IAAI,EAAG;YAChB,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC;SACjB;QACD,IAAK,CAAC,IAAI,IAAI,EAAG;YAChB,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,CAAC;SACjB;QACD,OAAO,CAAC,GAAG,CAAC,CAAC;IACd,CAAC;IAED,8DAA8D;IACpD,YAAY,CAA6B,QAA6C,EAAE,IAA8B,EAAE,MAAc;QAC/I,IAAI,GAAG,GAAQ,EAAE,CAAC;QAClB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,IAAI,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACvD,IAAI,EAAE,GAAkC,QAAQ,CAAC,CAAC,CAAC,CAAC;YACpD,IAAK,EAAE,IAAI,IAAI,EAAG;gBACjB,iBAAiB;gBACjB,SAAS;aACT;YACD,IAAK,EAAE,YAAY,IAAI,EAAG;gBACzB,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;aACb;SACD;QACD,OAAO,GAAG,CAAC;IACZ,CAAC;;AAtcsB,wCAAoB,GAAY,SAAS,CAAC;AAC1C,qCAAiB,GAAY,GAAG,CAAC;AACjC,mCAAe,GAAY,CAAC,CAAC;AAHrD,kDAwcC;AAED,yCAAyC;AAEzC;IAUC,YAAY,MAAmB,EAAE,KAAa,EAAE,IAAS;QACxD,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,IAAI,GAAG,IAAI,KAAK,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;IAC5C,CAAC;IAED;;OAEG;IACI,OAAO,CAAC,GAAa;QAC3B,OAAO,IAAI,CAAC,KAAK,CAAC;IACnB,CAAC;IAGM,QAAQ;QACd,IAAI,MAAM,GAAW,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC;QAC3C,IAAI,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;QACjC,MAAM,GAAG,MAAM,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;QACrD,OAAO,GAAG,GAAG,MAAM,GAAG,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC;YACrD,KAAK,GAAG,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;IAC7B,CAAC;CACD;AAPA;IADC,qBAAQ;gDAOR;AA9BF,4CA+BC;AAED,oBAAqB,SAAQ,gBAAgB;IAC5C,YAAY,MAAmB,EAAE,KAAa,EAAE,IAAQ;QACvD,KAAK,CAAC,MAAM,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;IAC5B,CAAC;IAGM,OAAO,CAAC,GAAa;QAC3B,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;QAC/B,IAAK,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,KAAK,aAAK,CAAC,GAAG,EAAG;YACrD,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;SACnD;QACD,OAAO,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;IACvB,CAAC;CACD;AAPA;IADC,qBAAQ;6CAOR;AAGF;;;GAGG;AACH,mBAAoB,SAAQ,cAAc;IACzC,YAAY,MAAmB,EAAE,KAAa,EAAE,IAAQ;QACvD,KAAK,CAAC,MAAM,EAAE,KAAK,GAAG,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,wCAAwC;IACzE,CAAC;CACD;AAED;;GAEG;AACH,eAAgB,SAAQ,gBAAgB;IAEvC,YAAY,MAAmB,EAAE,IAAY,EAAE,EAAU,EAAE,IAAQ;QAClE,KAAK,CAAC,MAAM,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;QAC1B,IAAI,CAAC,SAAS,GAAG,EAAE,CAAC;IACrB,CAAC;IAGM,OAAO,CAAC,GAAa;QAC3B,IAAK,IAAI,CAAC,IAAI,IAAI,IAAI,EAAG;YACxB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;SAC/B;QACD,OAAO,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;IAC3B,CAAC;IAGM,QAAQ;QACd,IAAK,IAAI,CAAC,IAAI,IAAI,IAAI,EAAG;YACxB,OAAO,YAAY,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC;gBAC/C,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,GAAG,CAAC;SAC/C;QACD,OAAO,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC;YAChD,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,KAAK,GAAG,IAAI,CAAC,IAAI,GAAG,KAAK,CAAC;IACtE,CAAC;CACD;AAhBA;IADC,qBAAQ;wCAMR;AAGD;IADC,qBAAQ;yCAQR","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:58.1768850-07:00\n\nimport { Interval } from \"./misc/Interval\";\nimport { Override } from \"./Decorators\";\nimport { Token } from \"./Token\";\nimport { TokenStream } from \"./TokenStream\";\n\nimport * as Utils from \"./misc/Utils\";\n\n/**\n * Useful for rewriting out a buffered input token stream after doing some\n * augmentation or other manipulations on it.\n *\n * You can insert stuff, replace, and delete chunks. Note that the operations\n * are done lazily--only if you convert the buffer to a {@link String} with\n * {@link TokenStream#getText()}. This is very efficient because you are not\n * moving data around all the time. As the buffer of tokens is converted to\n * strings, the {@link #getText()} method(s) scan the input token stream and\n * check to see if there is an operation at the current index. If so, the\n * operation is done and then normal {@link String} rendering continues on the\n * buffer. This is like having multiple Turing machine instruction streams\n * (programs) operating on a single input tape. :)\n *\n * This rewriter makes no modifications to the token stream. It does not ask the\n * stream to fill itself up nor does it advance the input cursor. The token\n * stream `TokenStream.index` will return the same value before and\n * after any {@link #getText()} call.\n *\n * The rewriter only works on tokens that you have in the buffer and ignores the\n * current input cursor. If you are buffering tokens on-demand, calling\n * {@link #getText()} halfway through the input will only do rewrites for those\n * tokens in the first half of the file.\n *\n * Since the operations are done lazily at {@link #getText}-time, operations do\n * not screw up the token index values. That is, an insert operation at token\n * index `i` does not change the index values for tokens\n * `i`+1..n-1.\n *\n * Because operations never actually alter the buffer, you may always get the\n * original token stream back without undoing anything. Since the instructions\n * are queued up, you can easily simulate transactions and roll back any changes\n * if there is an error just by removing instructions. For example,\n *\n * ```\n * CharStream input = new ANTLRFileStream(\"input\");\n * TLexer lex = new TLexer(input);\n * CommonTokenStream tokens = new CommonTokenStream(lex);\n * T parser = new T(tokens);\n * TokenStreamRewriter rewriter = new TokenStreamRewriter(tokens);\n * parser.startRule();\n * ```\n *\n * Then in the rules, you can execute (assuming rewriter is visible):\n *\n * ```\n * Token t,u;\n * ...\n * rewriter.insertAfter(t, \"text to put after t\");}\n * rewriter.insertAfter(u, \"text after u\");}\n * System.out.println(rewriter.getText());\n * ```\n *\n * You can also have multiple \"instruction streams\" and get multiple rewrites\n * from a single pass over the input. Just name the instruction streams and use\n * that name again when printing the buffer. This could be useful for generating\n * a C file and also its header file--all from the same buffer:\n *\n * ```\n * rewriter.insertAfter(\"pass1\", t, \"text to put after t\");}\n * rewriter.insertAfter(\"pass2\", u, \"text after u\");}\n * System.out.println(rewriter.getText(\"pass1\"));\n * System.out.println(rewriter.getText(\"pass2\"));\n * ```\n *\n * If you don't use named rewrite streams, a \"default\" stream is used as the\n * first example shows.\n */\nexport class TokenStreamRewriter {\n\tpublic static readonly DEFAULT_PROGRAM_NAME: string =  \"default\";\n\tpublic static readonly PROGRAM_INIT_SIZE: number =  100;\n\tpublic static readonly MIN_TOKEN_INDEX: number =  0;\n\n\t/** Our source stream */\n\tprotected tokens: TokenStream;\n\n\t/** You may have multiple, named streams of rewrite operations.\n\t *  I'm calling these things \"programs.\"\n\t *  Maps String (name) &rarr; rewrite (List)\n\t */\n\tprotected programs: Map<string, RewriteOperation[]>;\n\n\t/** Map String (program name) &rarr; Integer index */\n\tprotected lastRewriteTokenIndexes: Map<string, number>;\n\n\tconstructor(tokens: TokenStream)  {\n\t\tthis.tokens = tokens;\n\t\tthis.programs = new Map<string, RewriteOperation[]>();\n\t\tthis.programs.set(TokenStreamRewriter.DEFAULT_PROGRAM_NAME, []);\n\t\tthis.lastRewriteTokenIndexes = new Map<string, number>();\n\t}\n\n\tpublic getTokenStream(): TokenStream {\n\t\treturn this.tokens;\n\t}\n\n\tpublic rollback(instructionIndex: number): void;\n\t/** Rollback the instruction stream for a program so that\n\t *  the indicated instruction (via instructionIndex) is no\n\t *  longer in the stream. UNTESTED!\n\t */\n\tpublic rollback(instructionIndex: number, programName: string): void;\n\tpublic rollback(instructionIndex: number, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\n\t\tlet is: RewriteOperation[] | undefined =  this.programs.get(programName);\n\t\tif ( is != null ) {\n\t\t\tthis.programs.set(programName, is.slice(TokenStreamRewriter.MIN_TOKEN_INDEX, instructionIndex));\n\t\t}\n\t}\n\n\tpublic deleteProgram(): void;\n\n\t/** Reset the program so that no instructions exist */\n\tpublic deleteProgram(programName: string): void;\n\tpublic deleteProgram(programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\n\t\tthis.rollback(TokenStreamRewriter.MIN_TOKEN_INDEX, programName);\n\t}\n\n\tpublic insertAfter(t: Token, text: {}): void;\n\tpublic insertAfter(index: number, text: {}): void;\n\tpublic insertAfter(t: Token, text: {}, programName: string): void;\n\tpublic insertAfter(index: number, text: {}, programName: string): void;\n\tpublic insertAfter(tokenOrIndex: Token | number, text: {}, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\n\t\tlet index: number;\n\t\tif (typeof tokenOrIndex === \"number\") {\n\t\t\tindex = tokenOrIndex;\n\t\t} else {\n\t\t\tindex = tokenOrIndex.tokenIndex;\n\t\t}\n\n\t\t// to insert after, just insert before next index (even if past end)\n\t\tlet op = new InsertAfterOp(this.tokens, index, text);\n\t\tlet rewrites: RewriteOperation[] = this.getProgram(programName);\n\t\top.instructionIndex = rewrites.length;\n\t\trewrites.push(op);\n\t}\n\n\tpublic insertBefore(t: Token, text: {}): void;\n\tpublic insertBefore(index: number, text: {}): void;\n\tpublic insertBefore(t: Token, text: {}, programName: string): void;\n\tpublic insertBefore(index: number, text: {}, programName: string): void;\n\tpublic insertBefore(tokenOrIndex: Token | number, text: {}, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\n\t\tlet index: number;\n\t\tif (typeof tokenOrIndex === \"number\") {\n\t\t\tindex = tokenOrIndex;\n\t\t} else {\n\t\t\tindex = tokenOrIndex.tokenIndex;\n\t\t}\n\n\t\tlet op: RewriteOperation = new InsertBeforeOp(this.tokens, index, text);\n\t\tlet rewrites: RewriteOperation[] = this.getProgram(programName);\n\t\top.instructionIndex = rewrites.length;\n\t\trewrites.push(op);\n\t}\n\n\tpublic replaceSingle(index: number, text: {}): void;\n\tpublic replaceSingle(indexT: Token, text: {}): void;\n\tpublic replaceSingle(index: Token | number, text: {}): void {\n\t\tif (typeof index === \"number\") {\n\t\t\tthis.replace(index, index, text);\n\t\t} else {\n\t\t\tthis.replace(index, index, text);\n\t\t}\n\t}\n\n\tpublic replace(from: number, to: number, text: {}): void;\n\n\tpublic replace(from: Token, to: Token, text: {}): void;\n\n\tpublic replace(from: number, to: number, text: {}, programName: string): void;\n\n\tpublic replace(from: Token, to: Token, text: {}, programName: string): void;\n\n\tpublic replace(from: Token | number, to: Token | number, text: {}, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\n\t\tif (typeof from !== \"number\") {\n\t\t\tfrom = from.tokenIndex;\n\t\t}\n\n\t\tif (typeof to !== \"number\") {\n\t\t\tto = to.tokenIndex;\n\t\t}\n\n\t\tif ( from > to || from < 0 || to < 0 || to >= this.tokens.size ) {\n\t\t\tthrow new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);\n\t\t}\n\n\t\tlet op: RewriteOperation =  new ReplaceOp(this.tokens, from, to, text);\n\t\tlet rewrites: RewriteOperation[] = this.getProgram(programName);\n\t\top.instructionIndex = rewrites.length;\n\t\trewrites.push(op);\n\t}\n\n\tpublic delete(index: number): void;\n\n\tpublic delete(from: number, to: number): void;\n\n\tpublic delete(indexT: Token): void;\n\n\tpublic delete(from: Token, to: Token): void;\n\n\tpublic delete(from: number, to: number, programName: string): void;\n\n\tpublic delete(from: Token, to: Token, programName: string): void;\n\n\tpublic delete(from: Token | number, to?: Token | number, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\n\t\tif (to === undefined) {\n\t\t\tto = from;\n\t\t}\n\n\t\tif (typeof from === \"number\") {\n\t\t\tthis.replace(from, to as number, \"\", programName);\n\t\t} else {\n\t\t\tthis.replace(from, to as Token, \"\", programName);\n\t\t}\n\t}\n\n\tprotected getLastRewriteTokenIndex(): number;\n\n\tprotected getLastRewriteTokenIndex(programName: string): number;\n\n\tprotected getLastRewriteTokenIndex(programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): number {\n\t\tlet I: number | undefined = this.lastRewriteTokenIndexes.get(programName);\n\t\tif ( I == null ) {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn I;\n\t}\n\n\tprotected setLastRewriteTokenIndex(programName: string, i: number): void {\n\t\tthis.lastRewriteTokenIndexes.set(programName, i);\n\t}\n\n\tprotected getProgram(name: string): RewriteOperation[] {\n\t\tlet is: RewriteOperation[] | undefined = this.programs.get(name);\n\t\tif ( is == null ) {\n\t\t\tis = this.initializeProgram(name);\n\t\t}\n\n\t\treturn is;\n\t}\n\n\tprivate initializeProgram(name: string): RewriteOperation[] {\n\t\tlet is: RewriteOperation[] = [];\n\t\tthis.programs.set(name, is);\n\t\treturn is;\n\t}\n\n\t/** Return the text from the original tokens altered per the\n\t *  instructions given to this rewriter.\n\t */\n\tpublic getText(): string;\n\n\t/** Return the text from the original tokens altered per the\n\t *  instructions given to this rewriter in programName.\n\t *\n\t * @since 4.5\n\t */\n\tpublic getText(programName: string): string;\n\n\t/** Return the text associated with the tokens in the interval from the\n\t *  original token stream but with the alterations given to this rewriter.\n\t *  The interval refers to the indexes in the original token stream.\n\t *  We do not alter the token stream in any way, so the indexes\n\t *  and intervals are still consistent. Includes any operations done\n\t *  to the first and last token in the interval. So, if you did an\n\t *  insertBefore on the first token, you would get that insertion.\n\t *  The same is true if you do an insertAfter the stop token.\n\t */\n\tpublic getText(interval: Interval): string;\n\n\tpublic getText(interval: Interval, programName: string): string;\n\n\tpublic getText(intervalOrProgram?: Interval | string, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): string {\n\t\tlet interval: Interval;\n\t\tif (intervalOrProgram instanceof Interval) {\n\t\t\tinterval = intervalOrProgram;\n\t\t} else {\n\t\t\tinterval = Interval.of(0, this.tokens.size - 1);\n\t\t}\n\n\t\tif (typeof intervalOrProgram === \"string\") {\n\t\t\tprogramName = intervalOrProgram;\n\t\t}\n\n\t\tlet rewrites: RewriteOperation[] | undefined = this.programs.get(programName);\n\t\tlet start: number =  interval.a;\n\t\tlet stop: number =  interval.b;\n\n\t\t// ensure start/end are in range\n\t\tif ( stop > this.tokens.size - 1 ) {\n\t\t\tstop = this.tokens.size - 1;\n\t\t}\n\t\tif ( start < 0 ) {\n\t\t\tstart = 0;\n\t\t}\n\n\t\tif ( rewrites == null || rewrites.length === 0 ) {\n\t\t\treturn this.tokens.getText(interval); // no instructions to execute\n\t\t}\n\n\t\tlet buf: string[] = [];\n\n\t\t// First, optimize instruction stream\n\t\tlet indexToOp: Map<number, RewriteOperation> = this.reduceToSingleOperationPerIndex(rewrites);\n\n\t\t// Walk buffer, executing instructions and emitting tokens\n\t\tlet i: number =  start;\n\t\twhile ( i <= stop && i < this.tokens.size ) {\n\t\t\tlet op: RewriteOperation | undefined =  indexToOp.get(i);\n\t\t\tindexToOp.delete(i); // remove so any left have index size-1\n\t\t\tlet t: Token = this.tokens.get(i);\n\t\t\tif ( op == null ) {\n\t\t\t\t// no operation at that index, just dump token\n\t\t\t\tif ( t.type !== Token.EOF ) {\n\t\t\t\t\tbuf.push(String(t.text));\n\t\t\t\t}\n\t\t\t\ti++; // move to next token\n\t\t\t}\n\t\t\telse {\n\t\t\t\ti = op.execute(buf); // execute operation and skip\n\t\t\t}\n\t\t}\n\n\t\t// include stuff after end if it's last index in buffer\n\t\t// So, if they did an insertAfter(lastValidIndex, \"foo\"), include\n\t\t// foo if end==lastValidIndex.\n\t\tif ( stop === this.tokens.size - 1 ) {\n\t\t\t// Scan any remaining operations after last token\n\t\t\t// should be included (they will be inserts).\n\t\t\tfor (let op of indexToOp.values()) {\n\t\t\t\tif ( op.index >= this.tokens.size - 1 ) {\n\t\t\t\t\tbuf.push(op.text.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn buf.join(\"\");\n\t}\n\n\t/** We need to combine operations and report invalid operations (like\n\t *  overlapping replaces that are not completed nested). Inserts to\n\t *  same index need to be combined etc...  Here are the cases:\n\t *\n\t *  I.i.u I.j.v\t\t\t\t\t\t\t\tleave alone, nonoverlapping\n\t *  I.i.u I.i.v\t\t\t\t\t\t\t\tcombine: Iivu\n\t *\n\t *  R.i-j.u R.x-y.v\t| i-j in x-y\t\t\tdelete first R\n\t *  R.i-j.u R.i-j.v\t\t\t\t\t\t\tdelete first R\n\t *  R.i-j.u R.x-y.v\t| x-y in i-j\t\t\tERROR\n\t *  R.i-j.u R.x-y.v\t| boundaries overlap\tERROR\n\t *\n\t *  Delete special case of replace (text==undefined):\n\t *  D.i-j.u D.x-y.v\t| boundaries overlap\tcombine to max(min)..max(right)\n\t *\n\t *  I.i.u R.x-y.v | i in (x+1)-y\t\t\tdelete I (since insert before\n\t * \t\t\t\t\t\t\t\t\t\t\twe're not deleting i)\n\t *  I.i.u R.x-y.v | i not in (x+1)-y\t\tleave alone, nonoverlapping\n\t *  R.x-y.v I.i.u | i in x-y\t\t\t\tERROR\n\t *  R.x-y.v I.x.u \t\t\t\t\t\t\tR.x-y.uv (combine, delete I)\n\t *  R.x-y.v I.i.u | i not in x-y\t\t\tleave alone, nonoverlapping\n\t *\n\t *  I.i.u = insert u before op @ index i\n\t *  R.x-y.u = replace x-y indexed tokens with u\n\t *\n\t *  First we need to examine replaces. For any replace op:\n\t *\n\t * \t\t1. wipe out any insertions before op within that range.\n\t * \t\t2. Drop any replace op before that is contained completely within\n\t * \t that range.\n\t * \t\t3. Throw exception upon boundary overlap with any previous replace.\n\t *\n\t *  Then we can deal with inserts:\n\t *\n\t * \t\t1. for any inserts to same index, combine even if not adjacent.\n\t * \t\t2. for any prior replace with same left boundary, combine this\n\t * \t insert with replace and delete this replace.\n\t * \t\t3. throw exception if index in same range as previous replace\n\t *\n\t *  Don't actually delete; make op undefined in list. Easier to walk list.\n\t *  Later we can throw as we add to index &rarr; op map.\n\t *\n\t *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the\n\t *  inserted stuff would be before the replace range. But, if you\n\t *  add tokens in front of a method body '{' and then delete the method\n\t *  body, I think the stuff before the '{' you added should disappear too.\n\t *\n\t *  Return a map from token index to operation.\n\t */\n\tprotected reduceToSingleOperationPerIndex(rewrites: Array<RewriteOperation | undefined>): Map<number, RewriteOperation> {\n\t\t// console.log(`rewrites=[${Utils.join(rewrites, \", \")}]`);\n\n\t\t// WALK REPLACES\n\t\tfor (let i = 0; i < rewrites.length; i++) {\n\t\t\tlet op: RewriteOperation | undefined = rewrites[i];\n\t\t\tif ( op == null ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( !(op instanceof ReplaceOp) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet rop: ReplaceOp = op;\n\t\t\t// Wipe prior inserts within range\n\t\t\tlet inserts: InsertBeforeOp[] = this.getKindOfOps(rewrites, InsertBeforeOp, i);\n\t\t\tfor (let iop of inserts) {\n\t\t\t\tif ( iop.index === rop.index ) {\n\t\t\t\t\t// E.g., insert before 2, delete 2..2; update replace\n\t\t\t\t\t// text to include insert before, kill insert\n\t\t\t\t\trewrites[iop.instructionIndex] = undefined;\n\t\t\t\t\trop.text = iop.text.toString() + (rop.text != null ? rop.text.toString() : \"\");\n\t\t\t\t}\n\t\t\t\telse if ( iop.index > rop.index && iop.index <= rop.lastIndex ) {\n\t\t\t\t\t// delete insert as it's a no-op.\n\t\t\t\t\trewrites[iop.instructionIndex] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Drop any prior replaces contained within\n\t\t\tlet prevReplaces: ReplaceOp[] = this.getKindOfOps(rewrites, ReplaceOp, i);\n\t\t\tfor (let prevRop of prevReplaces) {\n\t\t\t\tif ( prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex ) {\n\t\t\t\t\t// delete replace as it's a no-op.\n\t\t\t\t\trewrites[prevRop.instructionIndex] = undefined;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// throw exception unless disjoint or identical\n\t\t\t\tlet disjoint: boolean =\n\t\t\t\t\tprevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;\n\t\t\t\t// Delete special case of replace (text==null):\n\t\t\t\t// D.i-j.u D.x-y.v\t| boundaries overlap\tcombine to max(min)..max(right)\n\t\t\t\tif ( prevRop.text == null && rop.text == null && !disjoint ) {\n\t\t\t\t\t// console.log(`overlapping deletes: ${prevRop}, ${rop}`);\n\t\t\t\t\trewrites[prevRop.instructionIndex] = undefined; // kill first delete\n\t\t\t\t\trop.index = Math.min(prevRop.index, rop.index);\n\t\t\t\t\trop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);\n\t\t\t\t\t// console.log(`new rop ${rop}`);\n\t\t\t\t}\n\t\t\t\telse if ( !disjoint ) {\n\t\t\t\t\tthrow new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// WALK INSERTS\n\t\tfor (let i = 0; i < rewrites.length; i++) {\n\t\t\tlet op: RewriteOperation | undefined = rewrites[i];\n\t\t\tif ( op == null ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( !(op instanceof InsertBeforeOp) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet iop: InsertBeforeOp =  op;\n\t\t\t// combine current insert with prior if any at same index\n\t\t\tlet prevInserts: InsertBeforeOp[] = this.getKindOfOps(rewrites, InsertBeforeOp, i);\n\t\t\tfor (let prevIop of prevInserts) {\n\t\t\t\tif ( prevIop.index === iop.index ) {\n\t\t\t\t\tif (prevIop instanceof InsertAfterOp) {\n\t\t\t\t\t\tiop.text = this.catOpText(prevIop.text, iop.text);\n\t\t\t\t\t\trewrites[prevIop.instructionIndex] = undefined;\n\t\t\t\t\t}\n\t\t\t\t\telse if (prevIop instanceof InsertBeforeOp) { // combine objects\n\t\t\t\t\t\t// convert to strings...we're in process of toString'ing\n\t\t\t\t\t\t// whole token buffer so no lazy eval issue with any templates\n\t\t\t\t\t\tiop.text = this.catOpText(iop.text, prevIop.text);\n\t\t\t\t\t\t// delete redundant prior insert\n\t\t\t\t\t\trewrites[prevIop.instructionIndex] = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// look for replaces where iop.index is in range; error\n\t\t\tlet prevReplaces: ReplaceOp[] = this.getKindOfOps(rewrites, ReplaceOp, i);\n\t\t\tfor (let rop of prevReplaces) {\n\t\t\t\tif ( iop.index === rop.index ) {\n\t\t\t\t\trop.text = this.catOpText(iop.text, rop.text);\n\t\t\t\t\trewrites[i] = undefined;\t// delete current insert\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( iop.index >= rop.index && iop.index <= rop.lastIndex ) {\n\t\t\t\t\tthrow new Error(`insert op ${iop} within boundaries of previous ${rop}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// console.log(`rewrites after=[${Utils.join(rewrites, \", \")}]`);\n\t\tlet m: Map<number, RewriteOperation> =  new Map<number, RewriteOperation>();\n\t\tfor (let op of rewrites) {\n\t\t\tif ( op == null ) {\n\t\t\t\t// ignore deleted ops\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( m.get(op.index) != null ) {\n\t\t\t\tthrow new Error(\"should only be one op per index\");\n\t\t\t}\n\t\t\tm.set(op.index, op);\n\t\t}\n\t\t// console.log(`index to op: ${m}`);\n\t\treturn m;\n\t}\n\n\tprotected catOpText(a: {}, b: {}): string {\n\t\tlet x: string =  \"\";\n\t\tlet y: string =  \"\";\n\t\tif ( a != null ) {\n\t\t\tx = a.toString();\n\t\t}\n\t\tif ( b != null ) {\n\t\t\ty = b.toString();\n\t\t}\n\t\treturn x + y;\n\t}\n\n\t/** Get all operations before an index of a particular kind */\n\tprotected getKindOfOps<T extends RewriteOperation>(rewrites: Array<RewriteOperation | undefined>, kind: {new(...args: any[]): T}, before: number): T[] {\n\t\tlet ops: T[] = [];\n\t\tfor (let i = 0; i < before && i < rewrites.length; i++) {\n\t\t\tlet op: RewriteOperation | undefined =  rewrites[i];\n\t\t\tif ( op == null ) {\n\t\t\t\t// ignore deleted\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( op instanceof kind ) {\n\t\t\t\tops.push(op);\n\t\t\t}\n\t\t}\n\t\treturn ops;\n\t}\n}\n\n// Define the rewrite operation hierarchy\n\nexport class RewriteOperation {\n\tprotected tokens: TokenStream;\n\t/** What index into rewrites List are we? */\n\tpublic instructionIndex: number;\n\t/** Token buffer index. */\n\tpublic index: number;\n\tpublic text: {};\n\n\tconstructor(tokens: TokenStream, index: number);\n\tconstructor(tokens: TokenStream, index: number, text: {});\n\tconstructor(tokens: TokenStream, index: number, text?: {}) {\n\t\tthis.tokens = tokens;\n\t\tthis.index = index;\n\t\tthis.text = text === undefined ? \"\" : text;\n\t}\n\n\t/** Execute the rewrite operation by possibly adding to the buffer.\n\t *  Return the index of the next token to operate on.\n\t */\n\tpublic execute(buf: string[]): number {\n\t\treturn this.index;\n\t}\n\n\t@Override\n\tpublic toString(): string {\n\t\tlet opName: string = this.constructor.name;\n\t\tlet $index = opName.indexOf(\"$\");\n\t\topName = opName.substring($index + 1, opName.length);\n\t\treturn \"<\" + opName + \"@\" + this.tokens.get(this.index) +\n\t\t\t\t\":\\\"\" + this.text + \"\\\">\";\n\t}\n}\n\nclass InsertBeforeOp extends RewriteOperation {\n\tconstructor(tokens: TokenStream, index: number, text: {}) {\n\t\tsuper(tokens, index, text);\n\t}\n\n\t@Override\n\tpublic execute(buf: string[]): number {\n\t\tbuf.push(this.text.toString());\n\t\tif ( this.tokens.get(this.index).type !== Token.EOF ) {\n\t\t\tbuf.push(String(this.tokens.get(this.index).text));\n\t\t}\n\t\treturn this.index + 1;\n\t}\n}\n\n/** Distinguish between insert after/before to do the \"insert afters\"\n *  first and then the \"insert befores\" at same index. Implementation\n *  of \"insert after\" is \"insert before index+1\".\n */\nclass InsertAfterOp extends InsertBeforeOp {\n\tconstructor(tokens: TokenStream, index: number, text: {}) {\n\t\tsuper(tokens, index + 1, text); // insert after is insert before index+1\n\t}\n}\n\n/** I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp\n *  instructions.\n */\nclass ReplaceOp extends RewriteOperation {\n\tpublic lastIndex: number;\n\tconstructor(tokens: TokenStream, from: number, to: number, text: {}) {\n\t\tsuper(tokens, from, text);\n\t\tthis.lastIndex = to;\n\t}\n\n\t@Override\n\tpublic execute(buf: string[]): number {\n\t\tif ( this.text != null ) {\n\t\t\tbuf.push(this.text.toString());\n\t\t}\n\t\treturn this.lastIndex + 1;\n\t}\n\n\t@Override\n\tpublic toString(): string {\n\t\tif ( this.text == null ) {\n\t\t\treturn \"<DeleteOp@\" + this.tokens.get(this.index) +\n\t\t\t\t\t\"..\" + this.tokens.get(this.lastIndex) + \">\";\n\t\t}\n\t\treturn \"<ReplaceOp@\" + this.tokens.get(this.index) +\n\t\t\t\t\"..\" + this.tokens.get(this.lastIndex) + \":\\\"\" + this.text + \"\\\">\";\n\t}\n}\n"]}