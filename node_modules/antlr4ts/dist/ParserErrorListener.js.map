{"version":3,"file":"ParserErrorListener.js","sourceRoot":"","sources":["../../src/ParserErrorListener.ts"],"names":[],"mappings":";AAAA;;;GAGG","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:52.9471863-07:00\nimport { ANTLRErrorListener } from \"./ANTLRErrorListener\";\nimport { ATNConfigSet } from \"./atn/ATNConfigSet\";\nimport { BitSet } from \"./misc/BitSet\";\nimport { DFA } from \"./dfa/DFA\";\nimport { Parser } from \"./Parser\";\nimport { SimulatorState } from \"./atn/SimulatorState\";\nimport { Token } from \"./Token\";\nimport * as Stubs from \"./misc/Stubs\";\nimport * as Exception from \"./RecognitionException\";\n\n/** How to emit recognition errors for parsers.\n */\nexport interface ParserErrorListener extends ANTLRErrorListener<Token> {\n\t/**\n\t * This method is called by the parser when a full-context prediction\n\t * results in an ambiguity.\n\t *\n\t * Each full-context prediction which does not result in a syntax error\n\t * will call either {@link #reportContextSensitivity} or\n\t * {@link #reportAmbiguity}.\n\t *\n\t * When `ambigAlts` is not `undefined`, it contains the set of potentially\n\t * viable alternatives identified by the prediction algorithm. When\n\t * `ambigAlts` is `undefined`, use\n\t * {@link ATNConfigSet#getRepresentedAlternatives} to obtain the represented\n\t * alternatives from the `configs` argument.\n\t *\n\t * When `exact` is `true`, *all* of the potentially\n\t * viable alternatives are truly viable, i.e. this is reporting an exact\n\t * ambiguity. When `exact` is `false`, *at least two* of\n\t * the potentially viable alternatives are viable for the current input, but\n\t * the prediction algorithm terminated as soon as it determined that at\n\t * least the *minimum* potentially viable alternative is truly\n\t * viable.\n\t *\n\t * When the {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} prediction\n\t * mode is used, the parser is required to identify exact ambiguities so\n\t * `exact` will always be `true`.\n\t *\n\t * @param recognizer the parser instance\n\t * @param dfa the DFA for the current decision\n\t * @param startIndex the input index where the decision started\n\t * @param stopIndex the input input where the ambiguity was identified\n\t * @param exact `true` if the ambiguity is exactly known, otherwise\n\t * `false`. This is always `true` when\n\t * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} is used.\n\t * @param ambigAlts the potentially ambiguous alternatives, or `undefined`\n\t * to indicate that the potentially ambiguous alternatives are the complete\n\t * set of represented alternatives in `configs`\n\t * @param configs the ATN configuration set where the ambiguity was\n\t * identified\n\t */\n\treportAmbiguity?: (\n\t\t/*@NotNull*/\n\t\trecognizer: Parser,\n\t\t/*@NotNull*/\n\t\tdfa: DFA,\n\t\tstartIndex: number,\n\t\tstopIndex: number,\n\t\texact: boolean,\n\t\tambigAlts: BitSet | undefined,\n\t\t/*@NotNull*/\n\t\tconfigs: ATNConfigSet) => void;\n\n\t/**\n\t * This method is called when an SLL conflict occurs and the parser is about\n\t * to use the full context information to make an LL decision.\n\t *\n\t * If one or more configurations in `configs` contains a semantic\n\t * predicate, the predicates are evaluated before this method is called. The\n\t * subset of alternatives which are still viable after predicates are\n\t * evaluated is reported in `conflictingAlts`.\n\t *\n\t * @param recognizer the parser instance\n\t * @param dfa the DFA for the current decision\n\t * @param startIndex the input index where the decision started\n\t * @param stopIndex the input index where the SLL conflict occurred\n\t * @param conflictingAlts The specific conflicting alternatives. If this is\n\t * `undefined`, the conflicting alternatives are all alternatives\n\t * represented in `configs`.\n\t * @param conflictState the simulator state when the SLL conflict was\n\t * detected\n\t */\n\treportAttemptingFullContext?: (\n\t\t/*@NotNull*/\n\t\trecognizer: Parser,\n\t\t/*@NotNull*/\n\t\tdfa: DFA,\n\t\tstartIndex: number,\n\t\tstopIndex: number,\n\t\tconflictingAlts: BitSet | undefined,\n\t\t/*@NotNull*/\n\t\tconflictState: SimulatorState) => void;\n\n\t/**\n\t * This method is called by the parser when a full-context prediction has a\n\t * unique result.\n\t *\n\t * Each full-context prediction which does not result in a syntax error\n\t * will call either {@link #reportContextSensitivity} or\n\t * {@link #reportAmbiguity}.\n\t *\n\t * For prediction implementations that only evaluate full-context\n\t * predictions when an SLL conflict is found (including the default\n\t * {@link ParserATNSimulator} implementation), this method reports cases\n\t * where SLL conflicts were resolved to unique full-context predictions,\n\t * i.e. the decision was context-sensitive. This report does not necessarily\n\t * indicate a problem, and it may appear even in completely unambiguous\n\t * grammars.\n\t *\n\t * `configs` may have more than one represented alternative if the\n\t * full-context prediction algorithm does not evaluate predicates before\n\t * beginning the full-context prediction. In all cases, the final prediction\n\t * is passed as the `prediction` argument.\n\t *\n\t * Note that the definition of \"context sensitivity\" in this method\n\t * differs from the concept in {@link DecisionInfo#contextSensitivities}.\n\t * This method reports all instances where an SLL conflict occurred but LL\n\t * parsing produced a unique result, whether or not that unique result\n\t * matches the minimum alternative in the SLL conflicting set.\n\t *\n\t * @param recognizer the parser instance\n\t * @param dfa the DFA for the current decision\n\t * @param startIndex the input index where the decision started\n\t * @param stopIndex the input index where the context sensitivity was\n\t * finally determined\n\t * @param prediction the unambiguous result of the full-context prediction\n\t * @param acceptState the simulator state when the unambiguous prediction\n\t * was determined\n\t */\n\treportContextSensitivity?: (\n\t\t/*@NotNull*/\n\t\trecognizer: Parser,\n\t\t/*@NotNull*/\n\t\tdfa: DFA,\n\t\tstartIndex: number,\n\t\tstopIndex: number,\n\t\tprediction: number,\n\t\t/*@NotNull*/\n\t\tacceptState: SimulatorState) => void;\n}\n"]}