{"version":3,"file":"IntStream.js","sourceRoot":"","sources":["../../src/IntStream.ts"],"names":[],"mappings":";AAAA;;;GAGG;;AAEH,wDAAwD;AAExD,IAAiB,SAAS,CAYzB;AAZD,WAAiB,SAAS;IACzB;;;OAGG;IACU,aAAG,GAAW,CAAC,CAAC,CAAC;IAE9B;;;OAGG;IACU,6BAAmB,GAAW,WAAW,CAAC;AACxD,CAAC,EAZgB,SAAS,GAAT,iBAAS,KAAT,iBAAS,QAYzB","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:51.6934376-07:00\n\nexport namespace IntStream {\n\t/**\n\t * The value returned by {@link #LA LA()} when the end of the stream is\n\t * reached.\n\t */\n\texport const EOF: number = -1;\n\n\t/**\n\t * The value returned by {@link #getSourceName} when the actual name of the\n\t * underlying source is not known.\n\t */\n\texport const UNKNOWN_SOURCE_NAME: string = \"<unknown>\";\n}\n\n/**\n * A simple stream of symbols whose values are represented as integers. This\n * interface provides *marked ranges* with support for a minimum level\n * of buffering necessary to implement arbitrary lookahead during prediction.\n * For more information on marked ranges, see {@link #mark}.\n *\n * **Initializing Methods:** Some methods in this interface have\n * unspecified behavior if no call to an initializing method has occurred after\n * the stream was constructed. The following is a list of initializing methods:\n *\n * * {@link #LA}\n * * {@link #consume}\n * * {@link #size}\n */\nexport interface IntStream {\n\t/**\n\t * Consumes the current symbol in the stream. This method has the following\n\t * effects:\n\t *\n\t * * **Forward movement:** The value of `index`\n\t *   before calling this method is less than the value of `index`\n\t *   after calling this method.\n\t * * **Ordered lookahead:** The value of `LA(1)` before\n\t *   calling this method becomes the value of `LA(-1)` after calling\n\t *   this method.\n\t *\n\t * Note that calling this method does not guarantee that `index` is\n\t * incremented by exactly 1, as that would preclude the ability to implement\n\t * filtering streams (e.g. {@link CommonTokenStream} which distinguishes\n\t * between \"on-channel\" and \"off-channel\" tokens).\n\t *\n\t * @throws IllegalStateException if an attempt is made to consume the\n\t * end of the stream (i.e. if `LA(1)==`{@link #EOF EOF} before calling\n\t * `consume`).\n\t */\n\tconsume(): void;\n\n\t/**\n\t * Gets the value of the symbol at offset `i` from the current\n\t * position. When `i==1`, this method returns the value of the current\n\t * symbol in the stream (which is the next symbol to be consumed). When\n\t * `i==-1`, this method returns the value of the previously read\n\t * symbol in the stream. It is not valid to call this method with\n\t * `i==0`, but the specific behavior is unspecified because this\n\t * method is frequently called from performance-critical code.\n\t *\n\t * This method is guaranteed to succeed if any of the following are true:\n\t *\n\t * * `i>0`\n\t * * `i==-1` and `index` returns a value greater\n\t *   than the value of `index` after the stream was constructed\n\t *   and `LA(1)` was called in that order. Specifying the current\n\t *   `index` relative to the index after the stream was created\n\t *   allows for filtering implementations that do not return every symbol\n\t *   from the underlying source. Specifying the call to `LA(1)`\n\t *   allows for lazily initialized streams.\n\t * * `LA(i)` refers to a symbol consumed within a marked region\n\t *   that has not yet been released.\n\t *\n\t * If `i` represents a position at or beyond the end of the stream,\n\t * this method returns {@link #EOF}.\n\t *\n\t * The return value is unspecified if `i<0` and fewer than `-i`\n\t * calls to {@link #consume consume()} have occurred from the beginning of\n\t * the stream before calling this method.\n\t *\n\t * @throws UnsupportedOperationException if the stream does not support\n\t * retrieving the value of the specified symbol\n\t */\n\tLA(i: number): number;\n\n\t/**\n\t * A mark provides a guarantee that {@link #seek seek()} operations will be\n\t * valid over a \"marked range\" extending from the index where `mark()`\n\t * was called to the current `index`. This allows the use of\n\t * streaming input sources by specifying the minimum buffering requirements\n\t * to support arbitrary lookahead during prediction.\n\t *\n\t * The returned mark is an opaque handle (type `int`) which is passed\n\t * to {@link #release release()} when the guarantees provided by the marked\n\t * range are no longer necessary. When calls to\n\t * `mark()`/`release()` are nested, the marks must be released\n\t * in reverse order of which they were obtained. Since marked regions are\n\t * used during performance-critical sections of prediction, the specific\n\t * behavior of invalid usage is unspecified (i.e. a mark is not released, or\n\t * a mark is released twice, or marks are not released in reverse order from\n\t * which they were created).\n\t *\n\t * The behavior of this method is unspecified if no call to an\n\t * {@link IntStream initializing method} has occurred after this stream was\n\t * constructed.\n\t *\n\t * This method does not change the current position in the input stream.\n\t *\n\t * The following example shows the use of {@link #mark mark()},\n\t * {@link #release release(mark)}, `index`, and\n\t * {@link #seek seek(index)} as part of an operation to safely work within a\n\t * marked region, then restore the stream position to its original value and\n\t * release the mark.\n\t *\n\t * ```\n\t * IntStream stream = ...;\n\t * int index = -1;\n\t * int mark = stream.mark();\n\t * try {\n\t *   index = stream.index;\n\t *   // perform work here...\n\t * } finally {\n\t *   if (index != -1) {\n\t *     stream.seek(index);\n\t *   }\n\t *   stream.release(mark);\n\t * }\n\t * ```\n\t *\n\t * @returns An opaque marker which should be passed to\n\t * {@link #release release()} when the marked range is no longer required.\n\t */\n\tmark(): number;\n\n\t/**\n\t * This method releases a marked range created by a call to\n\t * {@link #mark mark()}. Calls to `release()` must appear in the\n\t * reverse order of the corresponding calls to `mark()`. If a mark is\n\t * released twice, or if marks are not released in reverse order of the\n\t * corresponding calls to `mark()`, the behavior is unspecified.\n\t *\n\t * For more information and an example, see {@link #mark}.\n\t *\n\t * @param marker A marker returned by a call to `mark()`.\n\t * @see #mark\n\t */\n\trelease(marker: number): void;\n\n\t/**\n\t * Return the index into the stream of the input symbol referred to by\n\t * `LA(1)`.\n\t *\n\t * The behavior of this method is unspecified if no call to an\n\t * {@link IntStream initializing method} has occurred after this stream was\n\t * constructed.\n\t */\n\treadonly index: number;\n\n\t/**\n\t * Set the input cursor to the position indicated by `index`. If the\n\t * specified index lies past the end of the stream, the operation behaves as\n\t * though `index` was the index of the EOF symbol. After this method\n\t * returns without throwing an exception, then at least one of the following\n\t * will be true.\n\t *\n\t * * `index` will return the index of the first symbol\n\t *   appearing at or after the specified `index`. Specifically,\n\t *   implementations which filter their sources should automatically\n\t *   adjust `index` forward the minimum amount required for the\n\t *   operation to target a non-ignored symbol.\n\t * * `LA(1)` returns {@link #EOF}\n\t *\n\t * This operation is guaranteed to not throw an exception if `index`\n\t * lies within a marked region. For more information on marked regions, see\n\t * {@link #mark}. The behavior of this method is unspecified if no call to\n\t * an {@link IntStream initializing method} has occurred after this stream\n\t * was constructed.\n\t *\n\t * @param index The absolute index to seek to.\n\t *\n\t * @throws IllegalArgumentException if `index` is less than 0\n\t * @throws UnsupportedOperationException if the stream does not support\n\t * seeking to the specified index\n\t */\n\tseek(index: number): void;\n\n\t/**\n\t * Returns the total number of symbols in the stream, including a single EOF\n\t * symbol.\n\t *\n\t * @throws UnsupportedOperationException if the size of the stream is\n\t * unknown.\n\t */\n\treadonly size: number;\n\n\t/**\n\t * Gets the name of the underlying symbol source. This method returns a\n\t * non-undefined, non-empty string. If such a name is not known, this method\n\t * returns {@link #UNKNOWN_SOURCE_NAME}.\n\t */\n\t//@NotNull\n\treadonly sourceName: string;\n}\n"]}