{"version":3,"file":"CommonTokenFactory.js","sourceRoot":"","sources":["../../src/CommonTokenFactory.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;AAKH,+CAA4C;AAC5C,8CAA2C;AAC3C,6CAAwC;AAIxC;;;GAGG;AACH;IAiBC;;;;;;;;OAQG;IACH,YAAY,WAAoB,KAAK;QACpC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC1B,CAAC;IAGM,MAAM,CACZ,MAAqD,EACrD,IAAY,EACZ,IAAwB,EACxB,OAAe,EACf,KAAa,EACb,IAAY,EACZ,IAAY,EACZ,kBAA0B;QAE1B,IAAI,CAAC,GAAgB,IAAI,yBAAW,CAAC,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;QAC/E,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC;QACd,CAAC,CAAC,kBAAkB,GAAG,kBAAkB,CAAC;QAC1C,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,CAAC,QAAQ,IAAI,MAAM,CAAC,MAAM,IAAI,IAAI,EAAE;YAC3D,CAAC,CAAC,IAAI,GAAG,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,mBAAQ,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC;SACzD;QAED,OAAO,CAAC,CAAC;IACV,CAAC;IAGM,YAAY,CAAC,IAAY,EAAE,IAAY;QAC7C,OAAO,IAAI,yBAAW,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IACpC,CAAC;CACD;AAxBA;IADC,qBAAQ;gDAmBR;AAGD;IADC,qBAAQ;sDAGR;AAtDF,gDAuDC;AAED,WAAiB,kBAAkB;IAClC;;;;;OAKG;IACU,0BAAO,GAAiB,IAAI,kBAAkB,EAAE,CAAC;AAC/D,CAAC,EARgB,kBAAkB,GAAlB,0BAAkB,KAAlB,0BAAkB,QAQlC","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:50.3010112-07:00\n\nimport { CharStream } from \"./CharStream\";\nimport { CommonToken } from \"./CommonToken\";\nimport { Interval } from \"./misc/Interval\";\nimport { Override } from \"./Decorators\";\nimport { TokenFactory } from \"./TokenFactory\";\nimport { TokenSource } from \"./TokenSource\";\n\n/**\n * This default implementation of {@link TokenFactory} creates\n * {@link CommonToken} objects.\n */\nexport class CommonTokenFactory implements TokenFactory {\n\t/**\n\t * Indicates whether {@link CommonToken#setText} should be called after\n\t * constructing tokens to explicitly set the text. This is useful for cases\n\t * where the input stream might not be able to provide arbitrary substrings\n\t * of text from the input after the lexer creates a token (e.g. the\n\t * implementation of {@link CharStream#getText} in\n\t * {@link UnbufferedCharStream}\n\t * {@link UnsupportedOperationException}). Explicitly setting the token text\n\t * allows {@link Token#getText} to be called at any time regardless of the\n\t * input stream implementation.\n\t *\n\t * The default value is `false` to avoid the performance and memory\n\t * overhead of copying text for every token unless explicitly requested.\n\t */\n\tprotected copyText: boolean;\n\n\t/**\n\t * Constructs a {@link CommonTokenFactory} with the specified value for\n\t * {@link #copyText}.\n\t *\n\t * When `copyText` is `false`, the {@link #DEFAULT} instance\n\t * should be used instead of constructing a new instance.\n\t *\n\t * @param copyText The value for {@link #copyText}.\n\t */\n\tconstructor(copyText: boolean = false) {\n\t\tthis.copyText = copyText;\n\t}\n\n\t@Override\n\tpublic create(\n\t\tsource: { source?: TokenSource, stream?: CharStream },\n\t\ttype: number,\n\t\ttext: string | undefined,\n\t\tchannel: number,\n\t\tstart: number,\n\t\tstop: number,\n\t\tline: number,\n\t\tcharPositionInLine: number): CommonToken {\n\n\t\tlet t: CommonToken = new CommonToken(type, text, source, channel, start, stop);\n\t\tt.line = line;\n\t\tt.charPositionInLine = charPositionInLine;\n\t\tif (text == null && this.copyText && source.stream != null) {\n\t\t\tt.text = source.stream.getText(Interval.of(start, stop));\n\t\t}\n\n\t\treturn t;\n\t}\n\n\t@Override\n\tpublic createSimple(type: number, text: string): CommonToken {\n\t\treturn new CommonToken(type, text);\n\t}\n}\n\nexport namespace CommonTokenFactory {\n\t/**\n\t * The default {@link CommonTokenFactory} instance.\n\t *\n\t * This token factory does not explicitly copy token text when constructing\n\t * tokens.\n\t */\n\texport const DEFAULT: TokenFactory = new CommonTokenFactory();\n}\n"]}