{"version":3,"file":"ConflictInfo.js","sourceRoot":"","sources":["../../../src/atn/ConflictInfo.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;AAKH,8CAAyC;AACzC,uCAAuC;AAEvC;;;;GAIG;AACH;IAKC,YAAY,cAAsB,EAAE,KAAc;QACjD,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;QACtC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACpB,CAAC;IAED;;OAEG;IACH,IAAI,cAAc;QACjB,OAAO,IAAI,CAAC,eAAe,CAAC;IAC7B,CAAC;IAED;;;;;;;;;;;;OAYG;IACH,IAAI,OAAO;QACV,OAAO,IAAI,CAAC,KAAK,CAAC;IACnB,CAAC;IAGM,MAAM,CAAC,GAAQ;QACrB,IAAI,GAAG,KAAK,IAAI,EAAE;YACjB,OAAO,IAAI,CAAC;SACZ;aAAM,IAAI,CAAC,CAAC,GAAG,YAAY,YAAY,CAAC,EAAE;YAC1C,OAAO,KAAK,CAAC;SACb;QAED,OAAO,IAAI,CAAC,OAAO,KAAK,GAAG,CAAC,OAAO;eAC/B,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,cAAc,EAAE,GAAG,CAAC,cAAc,CAAC,CAAC;IAC3D,CAAC;IAGM,QAAQ;QACd,OAAO,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,CAAC;IACvC,CAAC;CACD;AAfA;IADC,qBAAQ;0CAUR;AAGD;IADC,qBAAQ;4CAGR;AAjDF,oCAkDC","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:28.0710131-07:00\n\nimport { BitSet } from \"../misc/BitSet\";\nimport { Override } from \"../Decorators\";\nimport * as Utils from \"../misc/Utils\";\n\n/**\n * This class stores information about a configuration conflict.\n *\n * @author Sam Harwell\n */\nexport class ConflictInfo {\n\tprivate _conflictedAlts: BitSet;\n\n\tprivate exact: boolean;\n\n\tconstructor(conflictedAlts: BitSet, exact: boolean) {\n\t\tthis._conflictedAlts = conflictedAlts;\n\t\tthis.exact = exact;\n\t}\n\n\t/**\n\t * Gets the set of conflicting alternatives for the configuration set.\n\t */\n\tget conflictedAlts(): BitSet {\n\t\treturn this._conflictedAlts;\n\t}\n\n\t/**\n\t * Gets whether or not the configuration conflict is an exact conflict.\n\t * An exact conflict occurs when the prediction algorithm determines that\n\t * the represented alternatives for a particular configuration set cannot be\n\t * further reduced by consuming additional input. After reaching an exact\n\t * conflict during an SLL prediction, only switch to full-context prediction\n\t * could reduce the set of viable alternatives. In LL prediction, an exact\n\t * conflict indicates a true ambiguity in the input.\n\t *\n\t * For the {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} prediction mode,\n\t * accept states are conflicting but not exact are treated as non-accept\n\t * states.\n\t */\n\tget isExact(): boolean {\n\t\treturn this.exact;\n\t}\n\n\t@Override\n\tpublic equals(obj: any): boolean {\n\t\tif (obj === this) {\n\t\t\treturn true;\n\t\t} else if (!(obj instanceof ConflictInfo)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.isExact === obj.isExact\n\t\t\t&& Utils.equals(this.conflictedAlts, obj.conflictedAlts);\n\t}\n\n\t@Override\n\tpublic hashCode(): number {\n\t\treturn this.conflictedAlts.hashCode();\n\t}\n}\n"]}