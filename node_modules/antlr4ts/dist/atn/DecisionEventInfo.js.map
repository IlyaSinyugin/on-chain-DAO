{"version":3,"file":"DecisionEventInfo.js","sourceRoot":"","sources":["../../../src/atn/DecisionEventInfo.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;;;;AAEH,wDAAwD;AAExD,8CAAwC;AAIxC;;;;;;;;;;;;;;GAcG;AACH,IAAa,iBAAiB,GAA9B;IAsCC,YACC,QAAgB,EAChB,KAAiC,EACxB,KAAkB,EAC3B,UAAkB,EAClB,SAAiB,EACjB,OAAgB;QAEhB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;QAC7B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;IACpB,CAAC;CACD,CAAA;AAlCA;IADC,oBAAO;gDACkB;AAnBd,iBAAiB;IAyC3B,WAAA,oBAAO,CAAA;GAzCG,iBAAiB,CAqD7B;AArDY,8CAAiB","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:28.2401032-07:00\n\nimport { NotNull } from \"../Decorators\";\nimport { SimulatorState } from \"./SimulatorState\";\nimport { TokenStream } from \"../TokenStream\";\n\n/**\n * This is the base class for gathering detailed information about prediction\n * events which occur during parsing.\n *\n * Note that we could record the parser call stack at the time this event\n * occurred but in the presence of left recursive rules, the stack is kind of\n * meaningless. It's better to look at the individual configurations for their\n * individual stacks. Of course that is a {@link PredictionContext} object\n * not a parse tree node and so it does not have information about the extent\n * (start...stop) of the various subtrees. Examining the stack tops of all\n * configurations provide the return states for the rule invocations.\n * From there you can get the enclosing rule.\n *\n * @since 4.3\n */\nexport class DecisionEventInfo {\n\t/**\n\t * The invoked decision number which this event is related to.\n\t *\n\t * @see ATN#decisionToState\n\t */\n\tpublic decision: number;\n\n\t/**\n\t * The simulator state containing additional information relevant to the\n\t * prediction state when the current event occurred, or `undefined` if no\n\t * additional information is relevant or available.\n\t */\n\tpublic state: SimulatorState | undefined;\n\n\t/**\n\t * The input token stream which is being parsed.\n\t */\n\t@NotNull\n\tpublic input: TokenStream;\n\n\t/**\n\t * The token index in the input stream at which the current prediction was\n\t * originally invoked.\n\t */\n\tpublic startIndex: number;\n\n\t/**\n\t * The token index in the input stream at which the current event occurred.\n\t */\n\tpublic stopIndex: number;\n\n\t/**\n\t * `true` if the current event occurred during LL prediction;\n\t * otherwise, `false` if the input occurred during SLL prediction.\n\t */\n\tpublic fullCtx: boolean;\n\n\tconstructor(\n\t\tdecision: number,\n\t\tstate: SimulatorState | undefined,\n\t\t@NotNull input: TokenStream,\n\t\tstartIndex: number,\n\t\tstopIndex: number,\n\t\tfullCtx: boolean) {\n\n\t\tthis.decision = decision;\n\t\tthis.fullCtx = fullCtx;\n\t\tthis.stopIndex = stopIndex;\n\t\tthis.input = input;\n\t\tthis.startIndex = startIndex;\n\t\tthis.state = state;\n\t}\n}\n"]}