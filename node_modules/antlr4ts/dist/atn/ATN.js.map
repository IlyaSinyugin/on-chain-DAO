{"version":3,"file":"ATN.js","sourceRoot":"","sources":["../../../src/atn/ATN.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;;;;AAEH,wDAAwD;AAExD,2DAAwD;AAIxD,oCAAiC;AACjC,qDAAkD;AAClD,iDAA8C;AAE9C,+CAA4C;AAC5C,8CAAwC;AACxC,+EAA4E;AAC5E,2DAAwD;AAKxD,oCAAiC;AAGjC,iCAAiC;AAEjC,MAAM;AACN,IAAa,GAAG,GAAhB;IA+DC,4DAA4D;IAC5D,YAAqB,WAAoB,EAAE,YAAoB;QA9D/C,WAAM,GAAe,EAAE,CAAC;QAExC;;;WAGG;QAEI,oBAAe,GAAoB,EAAE,CAAC;QAatC,yBAAoB,GAC1B,IAAI,GAAG,EAA4B,CAAC;QA4B9B,qBAAgB,GAAuB,EAAE,CAAC;QAEzC,iBAAY,GACnB,IAAI,+BAAc,CAAuC,mDAAwB,CAAC,QAAQ,CAAC,CAAC;QAGtF,kBAAa,GAAU,EAAE,CAAC;QAE1B,cAAS,GAAU,EAAE,CAAC;QAEtB,aAAQ,GAAwB,IAAI,GAAG,EAAkB,CAAC;QAIhE,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;QAC/B,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;IAClC,CAAC;IAEM,QAAQ;QACd,IAAI,CAAC,aAAa,GAAG,IAAI,KAAK,CAAM,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;QACjE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACnD,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC,GAAG,IAAI,SAAG,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;SAC5D;QAED,IAAI,CAAC,SAAS,GAAG,IAAI,KAAK,CAAM,IAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;QAC9D,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC/C,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI,SAAG,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC;SACtD;QAED,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;QAC1B,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;IACvB,CAAC;IAED,IAAI,gBAAgB;QACnB,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC;IAC/B,CAAC;IAEM,gBAAgB,CAAC,OAA0B;QACjD,OAAO,qCAAiB,CAAC,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAAC,YAAY,EAAE,IAAI,qCAAiB,CAAC,eAAe,EAAE,CAAC,CAAC;IAChH,CAAC;IAEM,gBAAgB;QACtB,MAAM,CAAC,IAAI,CAAC,aAAa,IAAI,IAAI,IAAI,IAAI,CAAC,aAAa,CAAC,MAAM,KAAK,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;QAChG,OAAO,IAAI,CAAC,aAAa,CAAC;IAC3B,CAAC;IAmBM,UAAU,CAAC,CAAW,EAAE,GAAuB;QACrD,IAAI,GAAG,EAAE;YACR,IAAI,IAAI,GAAgB,IAAI,yBAAW,CAAC,IAAI,CAAC,CAAC;YAC9C,IAAI,IAAI,GAAgB,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;YAC1C,OAAO,IAAI,CAAC;SACZ;aAAM;YACN,IAAI,CAAC,CAAC,mBAAmB,EAAE;gBAC1B,OAAO,CAAC,CAAC,mBAAmB,CAAC;aAC7B;YAED,CAAC,CAAC,mBAAmB,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,EAAE,qCAAiB,CAAC,WAAW,CAAC,CAAC;YAC1E,CAAC,CAAC,mBAAmB,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;YACxC,OAAO,CAAC,CAAC,mBAAmB,CAAC;SAC7B;IACF,CAAC;IAEM,QAAQ,CAAC,KAAe;QAC9B,KAAK,CAAC,GAAG,GAAG,IAAI,CAAC;QACjB,KAAK,CAAC,WAAW,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;QACvC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACzB,CAAC;IAEM,WAAW,CAAU,KAAe;QAC1C,qDAAqD;QACrD,IAAI,YAAY,GAAG,IAAI,2BAAY,EAAE,CAAC;QACtC,YAAY,CAAC,GAAG,GAAG,IAAI,CAAC;QACxB,YAAY,CAAC,WAAW,GAAG,KAAK,CAAC,WAAW,CAAC;QAC7C,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC,GAAG,YAAY,CAAC;IAC/C,CAAC;IAEM,UAAU,CAAU,IAAY,EAAW,CAAmB;QACpE,IAAI,CAAC,oBAAoB,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;QACvC,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAC9B,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,SAAG,CAAC,CAAC,CAAC,CAAC,CAAC;QAChC,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC,CAAC;IAC7B,CAAC;IAEM,mBAAmB,CAAU,CAAgB;QACnD,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAC7B,CAAC,CAAC,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC;QAC7C,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,SAAG,CAAC,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;QAChD,OAAO,CAAC,CAAC,QAAQ,CAAC;IACnB,CAAC;IAEM,gBAAgB,CAAC,QAAgB;QACvC,IAAI,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,EAAE;YACpC,OAAO,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;SACtC;QACD,OAAO,SAAS,CAAC;IAClB,CAAC;IAED,IAAI,iBAAiB;QACpB,OAAO,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC;IACpC,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;OAmCG;IAEI,iBAAiB,CAAC,WAAmB,EAAE,OAAgC;QAC7E,IAAI,WAAW,GAAG,CAAC,IAAI,WAAW,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YACzD,MAAM,IAAI,UAAU,CAAC,uBAAuB,CAAC,CAAC;SAC9C;QAED,IAAI,GAAG,GAA4B,OAAO,CAAC;QAC3C,IAAI,CAAC,GAAa,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;QAC3C,IAAI,SAAS,GAAgB,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QAChD,IAAI,CAAC,SAAS,CAAC,QAAQ,CAAC,aAAK,CAAC,OAAO,CAAC,EAAE;YACvC,OAAO,SAAS,CAAC;SACjB;QAED,IAAI,QAAQ,GAAgB,IAAI,yBAAW,EAAE,CAAC;QAC9C,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QAC3B,QAAQ,CAAC,MAAM,CAAC,aAAK,CAAC,OAAO,CAAC,CAAC;QAC/B,OAAO,GAAG,IAAI,IAAI,IAAI,GAAG,CAAC,aAAa,IAAI,CAAC,IAAI,SAAS,CAAC,QAAQ,CAAC,aAAK,CAAC,OAAO,CAAC,EAAE;YAClF,IAAI,aAAa,GAAa,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;YAC7D,IAAI,EAAE,GAAmB,aAAa,CAAC,UAAU,CAAC,CAAC,CAAmB,CAAC;YACvE,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,WAAW,CAAC,CAAC;YAC5C,QAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;YAC3B,QAAQ,CAAC,MAAM,CAAC,aAAK,CAAC,OAAO,CAAC,CAAC;YAC/B,GAAG,GAAG,GAAG,CAAC,OAAO,CAAC;SAClB;QAED,IAAI,SAAS,CAAC,QAAQ,CAAC,aAAK,CAAC,OAAO,CAAC,EAAE;YACtC,QAAQ,CAAC,GAAG,CAAC,aAAK,CAAC,GAAG,CAAC,CAAC;SACxB;QAED,OAAO,QAAQ,CAAC;IACjB,CAAC;CACD,CAAA;AA1OA;IADC,oBAAO;mCACgC;AAOxC;IADC,oBAAO;4CACqC;AAa7C;IADC,oBAAO;iDAE6B;AA4BrC;IADC,oBAAO;6CACyC;AAMjD;IADC,oBAAO;0CACyB;AAEjC;IADC,oBAAO;sCACqB;AAuD7B;IADC,oBAAO;qCAeP;AAQD;IAAoB,WAAA,oBAAO,CAAA;sCAM1B;AAED;IAAmB,WAAA,oBAAO,CAAA,EAAgB,WAAA,oBAAO,CAAA;qCAKhD;AAED;IAA4B,WAAA,oBAAO,CAAA;8CAKlC;AAkDD;IADC,oBAAO;4CA8BP;AA3OW,GAAG;IAgEF,WAAA,oBAAO,CAAA;GAhER,GAAG,CA4Of;AA5OY,kBAAG;AA8OhB,WAAiB,GAAG;IACN,sBAAkB,GAAW,CAAC,CAAC;AAC7C,CAAC,EAFgB,GAAG,GAAH,WAAG,KAAH,WAAG,QAEnB;AAhPY,kBAAG","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:25.1063510-07:00\n\nimport { Array2DHashMap } from \"../misc/Array2DHashMap\";\nimport { ATNState } from \"./ATNState\";\nimport { ATNType } from \"./ATNType\";\nimport { DecisionState } from \"./DecisionState\";\nimport { DFA } from \"../dfa/DFA\";\nimport { IntervalSet } from \"../misc/IntervalSet\";\nimport { InvalidState } from \"./InvalidState\";\nimport { LexerAction } from \"./LexerAction\";\nimport { LL1Analyzer } from \"./LL1Analyzer\";\nimport { NotNull } from \"../Decorators\";\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\nimport { PredictionContext } from \"./PredictionContext\";\nimport { RuleContext } from \"../RuleContext\";\nimport { RuleStartState } from \"./RuleStartState\";\nimport { RuleStopState } from \"./RuleStopState\";\nimport { RuleTransition } from \"./RuleTransition\";\nimport { Token } from \"../Token\";\nimport { TokensStartState } from \"./TokensStartState\";\n\nimport * as assert from \"assert\";\n\n/** */\nexport class ATN {\n\t@NotNull\n\tpublic readonly states: ATNState[] = [];\n\n\t/** Each subrule/rule is a decision point and we must track them so we\n\t *  can go back later and build DFA predictors for them.  This includes\n\t *  all the rules, subrules, optional blocks, ()+, ()* etc...\n\t */\n\t@NotNull\n\tpublic decisionToState: DecisionState[] = [];\n\n\t/**\n\t * Maps from rule index to starting state number.\n\t */\n\tpublic ruleToStartState: RuleStartState[];\n\n\t/**\n\t * Maps from rule index to stop state number.\n\t */\n\tpublic ruleToStopState: RuleStopState[];\n\n\t@NotNull\n\tpublic modeNameToStartState: Map<string, TokensStartState> =\n\t\tnew Map<string, TokensStartState>();\n\n\t/**\n\t * The type of the ATN.\n\t */\n\tpublic grammarType: ATNType;\n\n\t/**\n\t * The maximum value for any symbol recognized by a transition in the ATN.\n\t */\n\tpublic maxTokenType: number;\n\n\t/**\n\t * For lexer ATNs, this maps the rule index to the resulting token type.\n\t * For parser ATNs, this maps the rule index to the generated bypass token\n\t * type if the\n\t * {@link ATNDeserializationOptions#isGenerateRuleBypassTransitions}\n\t * deserialization option was specified; otherwise, this is `undefined`.\n\t */\n\tpublic ruleToTokenType: Int32Array;\n\n\t/**\n\t * For lexer ATNs, this is an array of {@link LexerAction} objects which may\n\t * be referenced by action transitions in the ATN.\n\t */\n\tpublic lexerActions: LexerAction[];\n\n\t@NotNull\n\tpublic modeToStartState: TokensStartState[] = [];\n\n\tprivate contextCache: Array2DHashMap<PredictionContext, PredictionContext> =\n\t\tnew Array2DHashMap<PredictionContext, PredictionContext>(ObjectEqualityComparator.INSTANCE);\n\n\t@NotNull\n\tpublic decisionToDFA: DFA[] = [];\n\t@NotNull\n\tpublic modeToDFA: DFA[] = [];\n\n\tpublic LL1Table: Map<number, number> = new Map<number, number>();\n\n\t/** Used for runtime deserialization of ATNs from strings */\n\tconstructor(@NotNull grammarType: ATNType, maxTokenType: number) {\n\t\tthis.grammarType = grammarType;\n\t\tthis.maxTokenType = maxTokenType;\n\t}\n\n\tpublic clearDFA(): void {\n\t\tthis.decisionToDFA = new Array<DFA>(this.decisionToState.length);\n\t\tfor (let i = 0; i < this.decisionToDFA.length; i++) {\n\t\t\tthis.decisionToDFA[i] = new DFA(this.decisionToState[i], i);\n\t\t}\n\n\t\tthis.modeToDFA = new Array<DFA>(this.modeToStartState.length);\n\t\tfor (let i = 0; i < this.modeToDFA.length; i++) {\n\t\t\tthis.modeToDFA[i] = new DFA(this.modeToStartState[i]);\n\t\t}\n\n\t\tthis.contextCache.clear();\n\t\tthis.LL1Table.clear();\n\t}\n\n\tget contextCacheSize(): number {\n\t\treturn this.contextCache.size;\n\t}\n\n\tpublic getCachedContext(context: PredictionContext): PredictionContext {\n\t\treturn PredictionContext.getCachedContext(context, this.contextCache, new PredictionContext.IdentityHashMap());\n\t}\n\n\tpublic getDecisionToDFA(): DFA[] {\n\t\tassert(this.decisionToDFA != null && this.decisionToDFA.length === this.decisionToState.length);\n\t\treturn this.decisionToDFA;\n\t}\n\n\t/** Compute the set of valid tokens that can occur starting in state `s`.\n\t *  If `ctx` is {@link PredictionContext#EMPTY_LOCAL}, the set of tokens will not include what can follow\n\t *  the rule surrounding `s`. In other words, the set will be\n\t *  restricted to tokens reachable staying within `s`'s rule.\n\t */\n\t// @NotNull\n\tpublic nextTokens(s: ATNState, /*@NotNull*/ ctx: PredictionContext): IntervalSet;\n\n\t/**\n\t * Compute the set of valid tokens that can occur starting in `s` and\n\t * staying in same rule. {@link Token#EPSILON} is in set if we reach end of\n\t * rule.\n\t */\n\t// @NotNull\n\tpublic nextTokens(/*@NotNull*/ s: ATNState): IntervalSet;\n\n\t@NotNull\n\tpublic nextTokens(s: ATNState, ctx?: PredictionContext): IntervalSet {\n\t\tif (ctx) {\n\t\t\tlet anal: LL1Analyzer = new LL1Analyzer(this);\n\t\t\tlet next: IntervalSet = anal.LOOK(s, ctx);\n\t\t\treturn next;\n\t\t} else {\n\t\t\tif (s.nextTokenWithinRule) {\n\t\t\t\treturn s.nextTokenWithinRule;\n\t\t\t}\n\n\t\t\ts.nextTokenWithinRule = this.nextTokens(s, PredictionContext.EMPTY_LOCAL);\n\t\t\ts.nextTokenWithinRule.setReadonly(true);\n\t\t\treturn s.nextTokenWithinRule;\n\t\t}\n\t}\n\n\tpublic addState(state: ATNState): void {\n\t\tstate.atn = this;\n\t\tstate.stateNumber = this.states.length;\n\t\tthis.states.push(state);\n\t}\n\n\tpublic removeState(@NotNull state: ATNState): void {\n\t\t// just replace the state, don't shift states in list\n\t\tlet invalidState = new InvalidState();\n\t\tinvalidState.atn = this;\n\t\tinvalidState.stateNumber = state.stateNumber;\n\t\tthis.states[state.stateNumber] = invalidState;\n\t}\n\n\tpublic defineMode(@NotNull name: string, @NotNull s: TokensStartState): void {\n\t\tthis.modeNameToStartState.set(name, s);\n\t\tthis.modeToStartState.push(s);\n\t\tthis.modeToDFA.push(new DFA(s));\n\t\tthis.defineDecisionState(s);\n\t}\n\n\tpublic defineDecisionState(@NotNull s: DecisionState): number {\n\t\tthis.decisionToState.push(s);\n\t\ts.decision = this.decisionToState.length - 1;\n\t\tthis.decisionToDFA.push(new DFA(s, s.decision));\n\t\treturn s.decision;\n\t}\n\n\tpublic getDecisionState(decision: number): DecisionState | undefined {\n\t\tif (this.decisionToState.length > 0) {\n\t\t\treturn this.decisionToState[decision];\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tget numberOfDecisions(): number {\n\t\treturn this.decisionToState.length;\n\t}\n\n\t/**\n\t * Computes the set of input symbols which could follow ATN state number\n\t * `stateNumber` in the specified full `context`. This method\n\t * considers the complete parser context, but does not evaluate semantic\n\t * predicates (i.e. all predicates encountered during the calculation are\n\t * assumed true). If a path in the ATN exists from the starting state to the\n\t * {@link RuleStopState} of the outermost context without matching any\n\t * symbols, {@link Token#EOF} is added to the returned set.\n\t *\n\t * If `context` is `undefined`, it is treated as\n\t * {@link ParserRuleContext#EMPTY}.\n\t *\n\t * Note that this does NOT give you the set of all tokens that could\n\t * appear at a given token position in the input phrase.  In other words, it\n\t * does not answer:\n\t *\n\t * > Given a specific partial input phrase, return the set of all\n\t * > tokens that can follow the last token in the input phrase.\n\t *\n\t * The big difference is that with just the input, the parser could land\n\t * right in the middle of a lookahead decision. Getting all\n\t * *possible* tokens given a partial input stream is a separate\n\t * computation. See https://github.com/antlr/antlr4/issues/1428\n\t *\n\t * For this function, we are specifying an ATN state and call stack to\n\t * compute what token(s) can come next and specifically: outside of a\n\t * lookahead decision. That is what you want for error reporting and\n\t * recovery upon parse error.\n\t *\n\t * @param stateNumber the ATN state number\n\t * @param context the full parse context\n\t * @returns The set of potentially valid input symbols which could follow the\n\t * specified state in the specified context.\n\t * @ if the ATN does not contain a state with\n\t * number `stateNumber`\n\t */\n\t@NotNull\n\tpublic getExpectedTokens(stateNumber: number, context: RuleContext | undefined): IntervalSet {\n\t\tif (stateNumber < 0 || stateNumber >= this.states.length) {\n\t\t\tthrow new RangeError(\"Invalid state number.\");\n\t\t}\n\n\t\tlet ctx: RuleContext | undefined = context;\n\t\tlet s: ATNState = this.states[stateNumber];\n\t\tlet following: IntervalSet = this.nextTokens(s);\n\t\tif (!following.contains(Token.EPSILON)) {\n\t\t\treturn following;\n\t\t}\n\n\t\tlet expected: IntervalSet = new IntervalSet();\n\t\texpected.addAll(following);\n\t\texpected.remove(Token.EPSILON);\n\t\twhile (ctx != null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n\t\t\tlet invokingState: ATNState = this.states[ctx.invokingState];\n\t\t\tlet rt: RuleTransition = invokingState.transition(0) as RuleTransition;\n\t\t\tfollowing = this.nextTokens(rt.followState);\n\t\t\texpected.addAll(following);\n\t\t\texpected.remove(Token.EPSILON);\n\t\t\tctx = ctx._parent;\n\t\t}\n\n\t\tif (following.contains(Token.EPSILON)) {\n\t\t\texpected.add(Token.EOF);\n\t\t}\n\n\t\treturn expected;\n\t}\n}\n\nexport namespace ATN {\n\texport const INVALID_ALT_NUMBER: number = 0;\n}\n"]}