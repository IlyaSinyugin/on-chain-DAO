{"version":3,"file":"AmbiguityInfo.js","sourceRoot":"","sources":["../../../src/atn/AmbiguityInfo.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;;;;AAKH,2DAAwD;AACxD,8CAAwC;AAIxC;;;;;;;;;;;;;;;;;;;;;;;;;;GA0BG;AACH,IAAa,aAAa,GAA1B,mBAA2B,SAAQ,qCAAiB;IAKnD;;;;;;;;;;;;;OAaG;IACH,YACC,QAAgB,EACP,KAAqB,EACrB,SAAiB,EACjB,KAAkB,EAC3B,UAAkB,EAClB,SAAiB;QACjB,KAAK,CAAC,QAAQ,EAAE,KAAK,EAAE,KAAK,EAAE,UAAU,EAAE,SAAS,EAAE,KAAK,CAAC,UAAU,CAAC,CAAC;QACvE,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC5B,CAAC;IAED;;;;OAIG;IAEH,IAAI,qBAAqB;QACxB,OAAO,IAAI,CAAC,SAAS,CAAC;IACvB,CAAC;CACD,CAAA;AApCA;IADC,oBAAO;gDACkB;AAiC1B;IADC,oBAAO;0DAGP;AAtCW,aAAa;IAqBvB,WAAA,oBAAO,CAAA;IACP,WAAA,oBAAO,CAAA;IACP,WAAA,oBAAO,CAAA;GAvBG,aAAa,CAuCzB;AAvCY,sCAAa","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:24.8229279-07:00\n\nimport { BitSet } from \"../misc/BitSet\";\nimport { DecisionEventInfo } from \"./DecisionEventInfo\";\nimport { NotNull } from \"../Decorators\";\nimport { SimulatorState } from \"./SimulatorState\";\nimport { TokenStream } from \"../TokenStream\";\n\n/**\n * This class represents profiling event information for an ambiguity.\n * Ambiguities are decisions where a particular input resulted in an SLL\n * conflict, followed by LL prediction also reaching a conflict state\n * (indicating a true ambiguity in the grammar).\n *\n * This event may be reported during SLL prediction in cases where the\n * conflicting SLL configuration set provides sufficient information to\n * determine that the SLL conflict is truly an ambiguity. For example, if none\n * of the ATN configurations in the conflicting SLL configuration set have\n * traversed a global follow transition (i.e.\n * {@link ATNConfig#getReachesIntoOuterContext} is `false` for all\n * configurations), then the result of SLL prediction for that input is known to\n * be equivalent to the result of LL prediction for that input.\n *\n * In some cases, the minimum represented alternative in the conflicting LL\n * configuration set is not equal to the minimum represented alternative in the\n * conflicting SLL configuration set. Grammars and inputs which result in this\n * scenario are unable to use {@link PredictionMode#SLL}, which in turn means\n * they cannot use the two-stage parsing strategy to improve parsing performance\n * for that input.\n *\n * @see ParserATNSimulator#reportAmbiguity\n * @see ParserErrorListener#reportAmbiguity\n *\n * @since 4.3\n */\nexport class AmbiguityInfo extends DecisionEventInfo {\n\t/** The set of alternative numbers for this decision event that lead to a valid parse. */\n\t@NotNull\n\tprivate ambigAlts: BitSet;\n\n\t/**\n\t * Constructs a new instance of the {@link AmbiguityInfo} class with the\n\t * specified detailed ambiguity information.\n\t *\n\t * @param decision The decision number\n\t * @param state The final simulator state identifying the ambiguous\n\t * alternatives for the current input\n\t * @param ambigAlts The set of alternatives in the decision that lead to a valid parse.\n\t *                  The predicted alt is the min(ambigAlts)\n\t * @param input The input token stream\n\t * @param startIndex The start index for the current prediction\n\t * @param stopIndex The index at which the ambiguity was identified during\n\t * prediction\n\t */\n\tconstructor(\n\t\tdecision: number,\n\t\t@NotNull state: SimulatorState,\n\t\t@NotNull ambigAlts: BitSet,\n\t\t@NotNull input: TokenStream,\n\t\tstartIndex: number,\n\t\tstopIndex: number) {\n\t\tsuper(decision, state, input, startIndex, stopIndex, state.useContext);\n\t\tthis.ambigAlts = ambigAlts;\n\t}\n\n\t/**\n\t * Gets the set of alternatives in the decision that lead to a valid parse.\n\t *\n\t * @since 4.5\n\t */\n\t@NotNull\n\tget ambiguousAlternatives(): BitSet {\n\t\treturn this.ambigAlts;\n\t}\n}\n"]}