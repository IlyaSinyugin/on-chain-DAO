{"version":3,"file":"LexerIndexedCustomAction.js","sourceRoot":"","sources":["../../../src/atn/LexerIndexedCustomAction.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;;;;AAOH,mDAAgD;AAChD,8CAAkD;AAElD;;;;;;;;;;;;GAYG;AACH,IAAa,wBAAwB,GAArC;IAIC;;;;;;;;;;;;OAYG;IACH,YAAY,MAAc,EAAW,MAAmB;QACvD,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IACvB,CAAC;IAED;;;;;;;OAOG;IACH,IAAI,MAAM;QACT,OAAO,IAAI,CAAC,OAAO,CAAC;IACrB,CAAC;IAED;;;;OAIG;IAEH,IAAI,MAAM;QACT,OAAO,IAAI,CAAC,OAAO,CAAC;IACrB,CAAC;IAED;;;;;OAKG;IAEH,IAAI,UAAU;QACb,OAAO,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC;IAChC,CAAC;IAED;;;OAGG;IAEH,IAAI,mBAAmB;QACtB,OAAO,IAAI,CAAC;IACb,CAAC;IAED;;;;;OAKG;IAEI,OAAO,CAAC,KAAY;QAC1B,wEAAwE;QACxE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IAC7B,CAAC;IAGM,QAAQ;QACd,IAAI,IAAI,GAAW,uBAAU,CAAC,UAAU,EAAE,CAAC;QAC3C,IAAI,GAAG,uBAAU,CAAC,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;QAC7C,IAAI,GAAG,uBAAU,CAAC,MAAM,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;QAC7C,OAAO,uBAAU,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;IACnC,CAAC;IAGM,MAAM,CAAC,GAAQ;QACrB,IAAI,GAAG,KAAK,IAAI,EAAE;YACjB,OAAO,IAAI,CAAC;SACZ;aAAM,IAAI,CAAC,CAAC,GAAG,YAAY,wBAAwB,CAAC,EAAE;YACtD,OAAO,KAAK,CAAC;SACb;QAED,OAAO,IAAI,CAAC,OAAO,KAAK,GAAG,CAAC,OAAO;eAC/B,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IACtC,CAAC;CACD,CAAA;AAvDA;IADC,oBAAO;sDAGP;AASD;IADC,qBAAQ;0DAGR;AAOD;IADC,qBAAQ;mEAGR;AASD;IADC,qBAAQ;uDAIR;AAGD;IADC,qBAAQ;wDAMR;AAGD;IADC,qBAAQ;sDAUR;AA9FW,wBAAwB;IAiBP,WAAA,oBAAO,CAAA;GAjBxB,wBAAwB,CA+FpC;AA/FY,4DAAwB","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:29.7613038-07:00\n\nimport { Lexer } from \"../Lexer\";\nimport { LexerAction } from \"./LexerAction\";\nimport { LexerActionType } from \"./LexerActionType\";\nimport { MurmurHash } from \"../misc/MurmurHash\";\nimport { NotNull, Override } from \"../Decorators\";\n\n/**\n * This implementation of {@link LexerAction} is used for tracking input offsets\n * for position-dependent actions within a {@link LexerActionExecutor}.\n *\n * This action is not serialized as part of the ATN, and is only required for\n * position-dependent lexer actions which appear at a location other than the\n * end of a rule. For more information about DFA optimizations employed for\n * lexer actions, see {@link LexerActionExecutor#append} and\n * {@link LexerActionExecutor#fixOffsetBeforeMatch}.\n *\n * @author Sam Harwell\n * @since 4.2\n */\nexport class LexerIndexedCustomAction implements LexerAction {\n\tprivate readonly _offset: number;\n\tprivate readonly _action: LexerAction;\n\n\t/**\n\t * Constructs a new indexed custom action by associating a character offset\n\t * with a {@link LexerAction}.\n\t *\n\t * Note: This class is only required for lexer actions for which\n\t * {@link LexerAction#isPositionDependent} returns `true`.\n\t *\n\t * @param offset The offset into the input {@link CharStream}, relative to\n\t * the token start index, at which the specified lexer action should be\n\t * executed.\n\t * @param action The lexer action to execute at a particular offset in the\n\t * input {@link CharStream}.\n\t */\n\tconstructor(offset: number, @NotNull action: LexerAction) {\n\t\tthis._offset = offset;\n\t\tthis._action = action;\n\t}\n\n\t/**\n\t * Gets the location in the input {@link CharStream} at which the lexer\n\t * action should be executed. The value is interpreted as an offset relative\n\t * to the token start index.\n\t *\n\t * @returns The location in the input {@link CharStream} at which the lexer\n\t * action should be executed.\n\t */\n\tget offset(): number {\n\t\treturn this._offset;\n\t}\n\n\t/**\n\t * Gets the lexer action to execute.\n\t *\n\t * @returns A {@link LexerAction} object which executes the lexer action.\n\t */\n\t@NotNull\n\tget action(): LexerAction {\n\t\treturn this._action;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * @returns This method returns the result of calling {@link #getActionType}\n\t * on the {@link LexerAction} returned by {@link #getAction}.\n\t */\n\t@Override\n\tget actionType(): LexerActionType {\n\t\treturn this._action.actionType;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t * @returns This method returns `true`.\n\t */\n\t@Override\n\tget isPositionDependent(): boolean {\n\t\treturn true;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * This method calls {@link #execute} on the result of {@link #getAction}\n\t * using the provided `lexer`.\n\t */\n\t@Override\n\tpublic execute(lexer: Lexer): void {\n\t\t// assume the input stream position was properly set by the calling code\n\t\tthis._action.execute(lexer);\n\t}\n\n\t@Override\n\tpublic hashCode(): number {\n\t\tlet hash: number = MurmurHash.initialize();\n\t\thash = MurmurHash.update(hash, this._offset);\n\t\thash = MurmurHash.update(hash, this._action);\n\t\treturn MurmurHash.finish(hash, 2);\n\t}\n\n\t@Override\n\tpublic equals(obj: any): boolean {\n\t\tif (obj === this) {\n\t\t\treturn true;\n\t\t} else if (!(obj instanceof LexerIndexedCustomAction)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._offset === obj._offset\n\t\t\t&& this._action.equals(obj._action);\n\t}\n}\n"]}