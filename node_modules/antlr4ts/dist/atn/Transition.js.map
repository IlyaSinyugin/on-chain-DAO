{"version":3,"file":"Transition.js","sourceRoot":"","sources":["../../../src/atn/Transition.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;;;;AAMH,8CAAwC;AAGxC;;;;;;;;;;;GAWG;AACH,IAAsB,UAAU,GAAhC;IAkCC,YAAqB,MAAgB;QACpC,IAAI,MAAM,IAAI,IAAI,EAAE;YACnB,MAAM,IAAI,KAAK,CAAC,wBAAwB,CAAC,CAAC;SAC1C;QAED,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACtB,CAAC;IAID;;;;;;;;OAQG;IACH,IAAI,SAAS;QACZ,OAAO,KAAK,CAAC;IACd,CAAC;IAED,IAAI,KAAK;QACR,OAAO,SAAS,CAAC;IAClB,CAAC;CAGD,CAAA;AA7DuB,6BAAkB,GAAa;IACrD,SAAS;IACT,SAAS;IACT,OAAO;IACP,MAAM;IACN,WAAW;IACX,MAAM;IACN,QAAQ;IACR,KAAK;IACL,SAAS;IACT,UAAU;IACV,YAAY;CACZ,CAAC;AAmBF;IADC,oBAAO;0CACgB;AAhCH,UAAU;IAkClB,WAAA,oBAAO,CAAA;GAlCC,UAAU,CA8D/B;AA9DqB,gCAAU","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:37.8530496-07:00\n\nimport { ATNState } from \"./ATNState\";\nimport { IntervalSet } from \"../misc/IntervalSet\";\nimport { NotNull } from \"../Decorators\";\nimport { TransitionType } from \"./TransitionType\";\n\n/** An ATN transition between any two ATN states.  Subclasses define\n *  atom, set, epsilon, action, predicate, rule transitions.\n *\n *  This is a one way link.  It emanates from a state (usually via a list of\n *  transitions) and has a target state.\n *\n *  Since we never have to change the ATN transitions once we construct it,\n *  we can fix these transitions as specific classes. The DFA transitions\n *  on the other hand need to update the labels as it adds transitions to\n *  the states. We'll use the term Edge for the DFA to distinguish them from\n *  ATN transitions.\n */\nexport abstract class Transition {\n\tpublic static readonly serializationNames: string[] = [\n\t\t\"INVALID\",\n\t\t\"EPSILON\",\n\t\t\"RANGE\",\n\t\t\"RULE\",\n\t\t\"PREDICATE\",\n\t\t\"ATOM\",\n\t\t\"ACTION\",\n\t\t\"SET\",\n\t\t\"NOT_SET\",\n\t\t\"WILDCARD\",\n\t\t\"PRECEDENCE\",\n\t];\n\n\t// @SuppressWarnings(\"serial\")\n\t// static serializationTypes: Map<Class<? extends Transition>, number> =\n\t// \tCollections.unmodifiableMap(new HashMap<Class<? extends Transition>, Integer>() {{\n\t// \t\tput(EpsilonTransition.class, EPSILON);\n\t// \t\tput(RangeTransition.class, RANGE);\n\t// \t\tput(RuleTransition.class, RULE);\n\t// \t\tput(PredicateTransition.class, PREDICATE);\n\t// \t\tput(AtomTransition.class, ATOM);\n\t// \t\tput(ActionTransition.class, ACTION);\n\t// \t\tput(SetTransition.class, SET);\n\t// \t\tput(NotSetTransition.class, NOT_SET);\n\t// \t\tput(WildcardTransition.class, WILDCARD);\n\t// \t\tput(PrecedencePredicateTransition.class, PRECEDENCE);\n\t// \t}});\n\n\t/** The target of this transition. */\n\t@NotNull\n\tpublic target: ATNState;\n\n\tconstructor(@NotNull target: ATNState) {\n\t\tif (target == null) {\n\t\t\tthrow new Error(\"target cannot be null.\");\n\t\t}\n\n\t\tthis.target = target;\n\t}\n\n\tpublic abstract readonly serializationType: TransitionType;\n\n\t/**\n\t * Determines if the transition is an \"epsilon\" transition.\n\t *\n\t * The default implementation returns `false`.\n\t *\n\t * @returns `true` if traversing this transition in the ATN does not\n\t * consume an input symbol; otherwise, `false` if traversing this\n\t * transition consumes (matches) an input symbol.\n\t */\n\tget isEpsilon(): boolean {\n\t\treturn false;\n\t}\n\n\tget label(): IntervalSet | undefined {\n\t\treturn undefined;\n\t}\n\n\tpublic abstract matches(symbol: number, minVocabSymbol: number, maxVocabSymbol: number): boolean;\n}\n"]}