{"version":3,"file":"LexerActionExecutor.js","sourceRoot":"","sources":["../../../src/atn/LexerActionExecutor.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:28.8810453-07:00\n\nimport { ArrayEqualityComparator } from \"../misc/ArrayEqualityComparator\";\nimport { CharStream } from \"../CharStream\";\nimport { Lexer } from \"../Lexer\";\nimport { LexerAction } from \"./LexerAction\";\nimport { LexerIndexedCustomAction } from \"./LexerIndexedCustomAction\";\nimport { MurmurHash } from \"../misc/MurmurHash\";\nimport { NotNull, Override } from \"../Decorators\";\n\n/**\n * Represents an executor for a sequence of lexer actions which traversed during\n * the matching operation of a lexer rule (token).\n *\n * The executor tracks position information for position-dependent lexer actions\n * efficiently, ensuring that actions appearing only at the end of the rule do\n * not cause bloating of the {@link DFA} created for the lexer.\n *\n * @author Sam Harwell\n * @since 4.2\n */\nexport class LexerActionExecutor {\n\t@NotNull\n\tprivate _lexerActions: LexerAction[];\n\n\t/**\n\t * Caches the result of {@link #hashCode} since the hash code is an element\n\t * of the performance-critical {@link LexerATNConfig#hashCode} operation.\n\t */\n\tprivate cachedHashCode: number;\n\n\t/**\n\t * Constructs an executor for a sequence of {@link LexerAction} actions.\n\t * @param lexerActions The lexer actions to execute.\n\t */\n\tconstructor(@NotNull lexerActions: LexerAction[]) {\n\t\tthis._lexerActions = lexerActions;\n\n\t\tlet hash: number = MurmurHash.initialize();\n\t\tfor (let lexerAction of lexerActions) {\n\t\t\thash = MurmurHash.update(hash, lexerAction);\n\t\t}\n\n\t\tthis.cachedHashCode = MurmurHash.finish(hash, lexerActions.length);\n\t}\n\n\t/**\n\t * Creates a {@link LexerActionExecutor} which executes the actions for\n\t * the input `lexerActionExecutor` followed by a specified\n\t * `lexerAction`.\n\t *\n\t * @param lexerActionExecutor The executor for actions already traversed by\n\t * the lexer while matching a token within a particular\n\t * {@link ATNConfig}. If this is `undefined`, the method behaves as though\n\t * it were an empty executor.\n\t * @param lexerAction The lexer action to execute after the actions\n\t * specified in `lexerActionExecutor`.\n\t *\n\t * @returns A {@link LexerActionExecutor} for executing the combine actions\n\t * of `lexerActionExecutor` and `lexerAction`.\n\t */\n\t@NotNull\n\tpublic static append(lexerActionExecutor: LexerActionExecutor | undefined, @NotNull lexerAction: LexerAction): LexerActionExecutor {\n\t\tif (!lexerActionExecutor) {\n\t\t\treturn new LexerActionExecutor([lexerAction]);\n\t\t}\n\n\t\tlet lexerActions = lexerActionExecutor._lexerActions.slice(0);\n\t\tlexerActions.push(lexerAction);\n\t\treturn new LexerActionExecutor(lexerActions);\n\t}\n\n\t/**\n\t * Creates a {@link LexerActionExecutor} which encodes the current offset\n\t * for position-dependent lexer actions.\n\t *\n\t * Normally, when the executor encounters lexer actions where\n\t * {@link LexerAction#isPositionDependent} returns `true`, it calls\n\t * {@link IntStream#seek} on the input {@link CharStream} to set the input\n\t * position to the *end* of the current token. This behavior provides\n\t * for efficient DFA representation of lexer actions which appear at the end\n\t * of a lexer rule, even when the lexer rule matches a variable number of\n\t * characters.\n\t *\n\t * Prior to traversing a match transition in the ATN, the current offset\n\t * from the token start index is assigned to all position-dependent lexer\n\t * actions which have not already been assigned a fixed offset. By storing\n\t * the offsets relative to the token start index, the DFA representation of\n\t * lexer actions which appear in the middle of tokens remains efficient due\n\t * to sharing among tokens of the same length, regardless of their absolute\n\t * position in the input stream.\n\t *\n\t * If the current executor already has offsets assigned to all\n\t * position-dependent lexer actions, the method returns `this`.\n\t *\n\t * @param offset The current offset to assign to all position-dependent\n\t * lexer actions which do not already have offsets assigned.\n\t *\n\t * @returns A {@link LexerActionExecutor} which stores input stream offsets\n\t * for all position-dependent lexer actions.\n\t */\n\tpublic fixOffsetBeforeMatch(offset: number): LexerActionExecutor {\n\t\tlet updatedLexerActions: LexerAction[] | undefined;\n\t\tfor (let i = 0; i < this._lexerActions.length; i++) {\n\t\t\tif (this._lexerActions[i].isPositionDependent && !(this._lexerActions[i] instanceof LexerIndexedCustomAction)) {\n\t\t\t\tif (!updatedLexerActions) {\n\t\t\t\t\tupdatedLexerActions = this._lexerActions.slice(0);\n\t\t\t\t}\n\n\t\t\t\tupdatedLexerActions[i] = new LexerIndexedCustomAction(offset, this._lexerActions[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!updatedLexerActions) {\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new LexerActionExecutor(updatedLexerActions);\n\t}\n\n\t/**\n\t * Gets the lexer actions to be executed by this executor.\n\t * @returns The lexer actions to be executed by this executor.\n\t */\n\t@NotNull\n\tget lexerActions(): LexerAction[] {\n\t\treturn this._lexerActions;\n\t}\n\n\t/**\n\t * Execute the actions encapsulated by this executor within the context of a\n\t * particular {@link Lexer}.\n\t *\n\t * This method calls {@link IntStream#seek} to set the position of the\n\t * `input` {@link CharStream} prior to calling\n\t * {@link LexerAction#execute} on a position-dependent action. Before the\n\t * method returns, the input position will be restored to the same position\n\t * it was in when the method was invoked.\n\t *\n\t * @param lexer The lexer instance.\n\t * @param input The input stream which is the source for the current token.\n\t * When this method is called, the current {@link IntStream#index} for\n\t * `input` should be the start of the following token, i.e. 1\n\t * character past the end of the current token.\n\t * @param startIndex The token start index. This value may be passed to\n\t * {@link IntStream#seek} to set the `input` position to the beginning\n\t * of the token.\n\t */\n\tpublic execute(@NotNull lexer: Lexer, input: CharStream, startIndex: number): void {\n\t\tlet requiresSeek: boolean = false;\n\t\tlet stopIndex: number = input.index;\n\t\ttry {\n\t\t\tfor (let lexerAction of this._lexerActions) {\n\t\t\t\tif (lexerAction instanceof LexerIndexedCustomAction) {\n\t\t\t\t\tlet offset: number = lexerAction.offset;\n\t\t\t\t\tinput.seek(startIndex + offset);\n\t\t\t\t\tlexerAction = lexerAction.action;\n\t\t\t\t\trequiresSeek = (startIndex + offset) !== stopIndex;\n\t\t\t\t} else if (lexerAction.isPositionDependent) {\n\t\t\t\t\tinput.seek(stopIndex);\n\t\t\t\t\trequiresSeek = false;\n\t\t\t\t}\n\n\t\t\t\tlexerAction.execute(lexer);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (requiresSeek) {\n\t\t\t\tinput.seek(stopIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic hashCode(): number {\n\t\treturn this.cachedHashCode;\n\t}\n\n\t@Override\n\tpublic equals(obj: any): boolean {\n\t\tif (obj === this) {\n\t\t\treturn true;\n\t\t} else if (!(obj instanceof LexerActionExecutor)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.cachedHashCode === obj.cachedHashCode\n\t\t\t&& ArrayEqualityComparator.INSTANCE.equals(this._lexerActions, obj._lexerActions);\n\t}\n}\n"]}