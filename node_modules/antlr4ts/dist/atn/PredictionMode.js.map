{"version":3,"file":"PredictionMode.js","sourceRoot":"","sources":["../../../src/atn/PredictionMode.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;AAEH,wDAAwD;AAExD,2DAAwD;AAOxD,mDAAgD;AAEhD,8CAAyC;AACzC,mDAAgD;AAGhD;;;;GAIG;AACH,IAAY,cAsDX;AAtDD,WAAY,cAAc;IACzB;;;;;;;;;;;;;;;;;;OAkBG;IACH,iDAAG,CAAA;IACH;;;;;;;;;;;;;;;OAeG;IACH,+CAAE,CAAA;IACF;;;;;;;;;;;;;;OAcG;IACH,2FAAwB,CAAA;AACzB,CAAC,EAtDW,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAsDzB;AAED,WAAiB,cAAc;IAC9B,uEAAuE;IACvE,gEAAgE;IAChE,sBAAuB,SAAQ,+BAAiC;QAC/D;YACC,KAAK,CAAC,qCAAqC,CAAC,QAAQ,CAAC,CAAC;QACvD,CAAC;KACD;IAED;QAGS,qCAAqC;YAC5C,sBAAsB;QACvB,CAAC;QAED;;;WAGG;QAEI,QAAQ,CAAC,CAAY;YAC3B,IAAI,QAAQ,GAAW,uBAAU,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YAChD,QAAQ,GAAG,uBAAU,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,CAAC;YAC5D,QAAQ,GAAG,uBAAU,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC;YAClD,QAAQ,GAAG,uBAAU,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;YAC1C,OAAO,QAAQ,CAAC;QACjB,CAAC;QAGM,MAAM,CAAC,CAAY,EAAE,CAAY;YACvC,IAAI,CAAC,KAAK,CAAC,EAAE;gBACZ,OAAO,IAAI,CAAC;aACZ;YACD,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,IAAI,EAAE;gBAC3B,OAAO,KAAK,CAAC;aACb;YACD,OAAO,CAAC,CAAC,KAAK,CAAC,WAAW,KAAK,CAAC,CAAC,KAAK,CAAC,WAAW;mBAC9C,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;QACjC,CAAC;;IA7BsB,8CAAQ,GAA0C,IAAI,qCAAqC,EAAE,CAAC;IAWrH;QADC,qBAAQ;yEAOR;IAGD;QADC,qBAAQ;uEAUR;IAGF;;;;;;;;;OASG;IACH,kCAAyC,OAAqB;QAC7D,KAAK,IAAI,CAAC,IAAI,OAAO,EAAE;YACtB,IAAI,CAAC,CAAC,KAAK,YAAY,6BAAa,EAAE;gBACrC,OAAO,IAAI,CAAC;aACZ;SACD;QAED,OAAO,KAAK,CAAC;IACd,CAAC;IARe,uCAAwB,2BAQvC,CAAA;IAED;;;;;;;;;OASG;IACH,oCAA2C,YAAY,CAAC,OAAqB;QAC5E,KAAK,IAAI,MAAM,IAAI,OAAO,EAAE;YAC3B,IAAI,CAAC,CAAC,MAAM,CAAC,KAAK,YAAY,6BAAa,CAAC,EAAE;gBAC7C,OAAO,KAAK,CAAC;aACb;SACD;QAED,OAAO,IAAI,CAAC;IACb,CAAC;IARe,yCAA0B,6BAQzC,CAAA;AACF,CAAC,EAjFgB,cAAc,GAAd,sBAAc,KAAd,sBAAc,QAiF9B","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:36.2673893-07:00\n\nimport { Array2DHashMap } from \"../misc/Array2DHashMap\";\nimport { ATN } from \"./ATN\";\nimport { ATNConfig } from \"./ATNConfig\";\nimport { ATNConfigSet } from \"./ATNConfigSet\";\nimport { ATNState } from \"./ATNState\";\nimport { BitSet } from \"../misc/BitSet\";\nimport { EqualityComparator } from \"../misc/EqualityComparator\";\nimport { MurmurHash } from \"../misc/MurmurHash\";\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\nimport { Override } from \"../Decorators\";\nimport { RuleStopState } from \"./RuleStopState\";\nimport { SemanticContext } from \"./SemanticContext\";\n\n/**\n * This enumeration defines the prediction modes available in ANTLR 4 along with\n * utility methods for analyzing configuration sets for conflicts and/or\n * ambiguities.\n */\nexport enum PredictionMode {\n\t/**\n\t * The SLL(*) prediction mode. This prediction mode ignores the current\n\t * parser context when making predictions. This is the fastest prediction\n\t * mode, and provides correct results for many grammars. This prediction\n\t * mode is more powerful than the prediction mode provided by ANTLR 3, but\n\t * may result in syntax errors for grammar and input combinations which are\n\t * not SLL.\n\t *\n\t * When using this prediction mode, the parser will either return a correct\n\t * parse tree (i.e. the same parse tree that would be returned with the\n\t * {@link #LL} prediction mode), or it will report a syntax error. If a\n\t * syntax error is encountered when using the {@link #SLL} prediction mode,\n\t * it may be due to either an actual syntax error in the input or indicate\n\t * that the particular combination of grammar and input requires the more\n\t * powerful {@link #LL} prediction abilities to complete successfully.\n\t *\n\t * This prediction mode does not provide any guarantees for prediction\n\t * behavior for syntactically-incorrect inputs.\n\t */\n\tSLL,\n\t/**\n\t * The LL(*) prediction mode. This prediction mode allows the current parser\n\t * context to be used for resolving SLL conflicts that occur during\n\t * prediction. This is the fastest prediction mode that guarantees correct\n\t * parse results for all combinations of grammars with syntactically correct\n\t * inputs.\n\t *\n\t * When using this prediction mode, the parser will make correct decisions\n\t * for all syntactically-correct grammar and input combinations. However, in\n\t * cases where the grammar is truly ambiguous this prediction mode might not\n\t * report a precise answer for *exactly which* alternatives are\n\t * ambiguous.\n\t *\n\t * This prediction mode does not provide any guarantees for prediction\n\t * behavior for syntactically-incorrect inputs.\n\t */\n\tLL,\n\t/**\n\t * The LL(*) prediction mode with exact ambiguity detection. In addition to\n\t * the correctness guarantees provided by the {@link #LL} prediction mode,\n\t * this prediction mode instructs the prediction algorithm to determine the\n\t * complete and exact set of ambiguous alternatives for every ambiguous\n\t * decision encountered while parsing.\n\t *\n\t * This prediction mode may be used for diagnosing ambiguities during\n\t * grammar development. Due to the performance overhead of calculating sets\n\t * of ambiguous alternatives, this prediction mode should be avoided when\n\t * the exact results are not necessary.\n\t *\n\t * This prediction mode does not provide any guarantees for prediction\n\t * behavior for syntactically-incorrect inputs.\n\t */\n\tLL_EXACT_AMBIG_DETECTION,\n}\n\nexport namespace PredictionMode {\n\t/** A Map that uses just the state and the stack context as the key. */\n\t// NOTE: Base type used to be FlexibleHashMap<ATNConfig, BitSet>\n\tclass AltAndContextMap extends Array2DHashMap<ATNConfig, BitSet> {\n\t\tconstructor() {\n\t\t\tsuper(AltAndContextConfigEqualityComparator.INSTANCE);\n\t\t}\n\t}\n\n\tclass AltAndContextConfigEqualityComparator implements EqualityComparator<ATNConfig> {\n\t\tpublic static readonly INSTANCE: AltAndContextConfigEqualityComparator = new AltAndContextConfigEqualityComparator();\n\n\t\tprivate AltAndContextConfigEqualityComparator() {\n\t\t\t// intentionally empty\n\t\t}\n\n\t\t/**\n\t\t * The hash code is only a function of the {@link ATNState#stateNumber}\n\t\t * and {@link ATNConfig#context}.\n\t\t */\n\t\t@Override\n\t\tpublic hashCode(o: ATNConfig): number {\n\t\t\tlet hashCode: number = MurmurHash.initialize(7);\n\t\t\thashCode = MurmurHash.update(hashCode, o.state.stateNumber);\n\t\t\thashCode = MurmurHash.update(hashCode, o.context);\n\t\t\thashCode = MurmurHash.finish(hashCode, 2);\n\t\t\treturn hashCode;\n\t\t}\n\n\t\t@Override\n\t\tpublic equals(a: ATNConfig, b: ATNConfig): boolean {\n\t\t\tif (a === b) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (a == null || b == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn a.state.stateNumber === b.state.stateNumber\n\t\t\t\t&& a.context.equals(b.context);\n\t\t}\n\t}\n\n\t/**\n\t * Checks if any configuration in `configs` is in a\n\t * {@link RuleStopState}. Configurations meeting this condition have reached\n\t * the end of the decision rule (local context) or end of start rule (full\n\t * context).\n\t *\n\t * @param configs the configuration set to test\n\t * @returns `true` if any configuration in `configs` is in a\n\t * {@link RuleStopState}, otherwise `false`\n\t */\n\texport function hasConfigInRuleStopState(configs: ATNConfigSet): boolean {\n\t\tfor (let c of configs) {\n\t\t\tif (c.state instanceof RuleStopState) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks if all configurations in `configs` are in a\n\t * {@link RuleStopState}. Configurations meeting this condition have reached\n\t * the end of the decision rule (local context) or end of start rule (full\n\t * context).\n\t *\n\t * @param configs the configuration set to test\n\t * @returns `true` if all configurations in `configs` are in a\n\t * {@link RuleStopState}, otherwise `false`\n\t */\n\texport function allConfigsInRuleStopStates(/*@NotNull*/ configs: ATNConfigSet): boolean {\n\t\tfor (let config of configs) {\n\t\t\tif (!(config.state instanceof RuleStopState)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n}\n"]}