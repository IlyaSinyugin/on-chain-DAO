{"version":3,"file":"RecognitionException.js","sourceRoot":"","sources":["../../src/RecognitionException.ts"],"names":[],"mappings":";AAAA;;;GAGG;;AAcH;;;;;GAKG;AACH,0BAAkC,SAAQ,KAAK;IAkC9C,YACC,UAAsD,EACtD,KAAyC,EACzC,GAAuB,EACvB,OAAgB;QAChB,KAAK,CAAC,OAAO,CAAC,CAAC;QAtBR,oBAAe,GAAW,CAAC,CAAC,CAAC;QAwBpC,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC;QAC9B,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC;QACf,IAAI,UAAU,EAAE;YACf,IAAI,CAAC,eAAe,GAAG,UAAU,CAAC,KAAK,CAAC;SACxC;IACF,CAAC;IAED;;;;;;;;OAQG;IACH,IAAI,cAAc;QACjB,OAAO,IAAI,CAAC,eAAe,CAAC;IAC7B,CAAC;IAES,iBAAiB,CAAC,cAAsB;QACjD,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;IACvC,CAAC;IAED;;;;;;;;;OASG;IACH,IAAI,cAAc;QACjB,IAAI,IAAI,CAAC,WAAW,EAAE;YACrB,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,iBAAiB,CAAC,IAAI,CAAC,eAAe,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC;SAC9E;QACD,OAAO,SAAS,CAAC;IAClB,CAAC;IAED;;;;;;;OAOG;IACH,IAAI,OAAO;QACV,OAAO,IAAI,CAAC,GAAG,CAAC;IACjB,CAAC;IAED;;;;;;;;;OASG;IAEH,IAAI,WAAW;QACd,OAAO,IAAI,CAAC,KAAK,CAAC;IACnB,CAAC;IAEM,iBAAiB,CAAC,UAAmC;QAC3D,IAAI,UAAU,IAAI,UAAU,KAAK,IAAI,CAAC,WAAW,EAAE;YAClD,OAAO,SAAS,CAAC;SACjB;QACD,OAAO,IAAI,CAAC,cAAc,CAAC;IAC5B,CAAC;IAES,iBAAiB,CAC1B,UAAoC,EACpC,cAAwB;QACxB,IAAI,UAAU,KAAK,IAAI,CAAC,WAAW,EAAE;YACpC,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;SACrC;IACF,CAAC;IAED;;;;;;;OAOG;IACH,IAAI,UAAU;QACb,OAAO,IAAI,CAAC,WAAW,CAAC;IACzB,CAAC;CACD;AAxID,oDAwIC","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:57.0697674-07:00\nimport { CharStream } from \"./CharStream\";\nimport { IntervalSet } from \"./misc/IntervalSet\";\nimport { IntStream } from \"./IntStream\";\nimport { Lexer } from \"./Lexer\";\nimport { Parser } from \"./Parser\";\nimport { ParserRuleContext } from \"./ParserRuleContext\";\nimport { Recognizer } from \"./Recognizer\";\nimport { RuleContext } from \"./RuleContext\";\nimport { Token } from \"./Token\";\n\n\n/** The root of the ANTLR exception hierarchy. In general, ANTLR tracks just\n *  3 kinds of errors: prediction errors, failed predicate errors, and\n *  mismatched input errors. In each case, the parser knows where it is\n *  in the input, where it is in the ATN, the rule invocation stack,\n *  and what kind of problem occurred.\n */\nexport class RecognitionException extends Error {\n\t// private static serialVersionUID: number =  -3861826954750022374L;\n\n\t/** The {@link Recognizer} where this exception originated. */\n\tprivate _recognizer?: Recognizer<any, any>;\n\n\tprivate ctx?: RuleContext;\n\n\tprivate input?: IntStream;\n\n\t/**\n\t * The current {@link Token} when an error occurred. Since not all streams\n\t * support accessing symbols by index, we have to track the {@link Token}\n\t * instance itself.\n\t */\n\tprivate offendingToken?: Token;\n\n\tprivate _offendingState: number = -1;\n\n\tconstructor(\n\t\tlexer: Lexer | undefined,\n\t\tinput: CharStream);\n\n\tconstructor(\n\t\trecognizer: Recognizer<Token, any> | undefined,\n\t\tinput: IntStream | undefined,\n\t\tctx: ParserRuleContext | undefined);\n\n\tconstructor(\n\t\trecognizer: Recognizer<Token, any> | undefined,\n\t\tinput: IntStream | undefined,\n\t\tctx: ParserRuleContext | undefined,\n\t\tmessage: string);\n\n\tconstructor(\n\t\trecognizer: Lexer | Recognizer<Token, any> | undefined,\n\t\tinput: CharStream | IntStream | undefined,\n\t\tctx?: ParserRuleContext,\n\t\tmessage?: string) {\n\t\tsuper(message);\n\n\t\tthis._recognizer = recognizer;\n\t\tthis.input = input;\n\t\tthis.ctx = ctx;\n\t\tif (recognizer) {\n\t\t\tthis._offendingState = recognizer.state;\n\t\t}\n\t}\n\n\t/**\n\t * Get the ATN state number the parser was in at the time the error\n\t * occurred. For {@link NoViableAltException} and\n\t * {@link LexerNoViableAltException} exceptions, this is the\n\t * {@link DecisionState} number. For others, it is the state whose outgoing\n\t * edge we couldn't match.\n\t *\n\t * If the state number is not known, this method returns -1.\n\t */\n\tget offendingState(): number {\n\t\treturn this._offendingState;\n\t}\n\n\tprotected setOffendingState(offendingState: number): void {\n\t\tthis._offendingState = offendingState;\n\t}\n\n\t/**\n\t * Gets the set of input symbols which could potentially follow the\n\t * previously matched symbol at the time this exception was thrown.\n\t *\n\t * If the set of expected tokens is not known and could not be computed,\n\t * this method returns `undefined`.\n\t *\n\t * @returns The set of token types that could potentially follow the current\n\t * state in the ATN, or `undefined` if the information is not available.\n\t */\n\tget expectedTokens(): IntervalSet | undefined {\n\t\tif (this._recognizer) {\n\t\t\treturn this._recognizer.atn.getExpectedTokens(this._offendingState, this.ctx);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Gets the {@link RuleContext} at the time this exception was thrown.\n\t *\n\t * If the context is not available, this method returns `undefined`.\n\t *\n\t * @returns The {@link RuleContext} at the time this exception was thrown.\n\t * If the context is not available, this method returns `undefined`.\n\t */\n\tget context(): RuleContext | undefined {\n\t\treturn this.ctx;\n\t}\n\n\t/**\n\t * Gets the input stream which is the symbol source for the recognizer where\n\t * this exception was thrown.\n\t *\n\t * If the input stream is not available, this method returns `undefined`.\n\t *\n\t * @returns The input stream which is the symbol source for the recognizer\n\t * where this exception was thrown, or `undefined` if the stream is not\n\t * available.\n\t */\n\n\tget inputStream(): IntStream | undefined {\n\t\treturn this.input;\n\t}\n\n\tpublic getOffendingToken(recognizer?: Recognizer<Token, any>): Token | undefined {\n\t\tif (recognizer && recognizer !== this._recognizer) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.offendingToken;\n\t}\n\n\tprotected setOffendingToken<TSymbol extends Token>(\n\t\trecognizer: Recognizer<TSymbol, any>,\n\t\toffendingToken?: TSymbol): void {\n\t\tif (recognizer === this._recognizer) {\n\t\t\tthis.offendingToken = offendingToken;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the {@link Recognizer} where this exception occurred.\n\t *\n\t * If the recognizer is not available, this method returns `undefined`.\n\t *\n\t * @returns The recognizer where this exception occurred, or `undefined` if\n\t * the recognizer is not available.\n\t */\n\tget recognizer(): Recognizer<any, any> | undefined {\n\t\treturn this._recognizer;\n\t}\n}\n"]}