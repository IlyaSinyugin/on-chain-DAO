{"version":3,"file":"DiagnosticErrorListener.js","sourceRoot":"","sources":["../../src/DiagnosticErrorListener.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:51.2133685-07:00\n\nimport { ATNConfig } from \"./atn/ATNConfig\";\nimport { ATNConfigSet } from \"./atn/ATNConfigSet\";\nimport { BitSet } from \"./misc/BitSet\";\nimport { DFA } from \"./dfa/DFA\";\nimport { Parser } from \"./Parser\";\nimport { ParserErrorListener } from \"./ParserErrorListener\";\nimport { RecognitionException } from \"./RecognitionException\";\nimport { Recognizer } from \"./Recognizer\";\nimport { SimulatorState } from \"./atn/SimulatorState\";\nimport { Token } from \"./Token\";\nimport { Override, NotNull } from \"./Decorators\";\nimport { Interval } from \"./misc/Interval\";\n\n/**\n * This implementation of {@link ANTLRErrorListener} can be used to identify\n * certain potential correctness and performance problems in grammars. \"Reports\"\n * are made by calling {@link Parser#notifyErrorListeners} with the appropriate\n * message.\n *\n * * **Ambiguities**: These are cases where more than one path through the\n *   grammar can match the input.\n * * **Weak context sensitivity**: These are cases where full-context\n *   prediction resolved an SLL conflict to a unique alternative which equaled the\n *   minimum alternative of the SLL conflict.\n * * **Strong (forced) context sensitivity**: These are cases where the\n *   full-context prediction resolved an SLL conflict to a unique alternative,\n *   *and* the minimum alternative of the SLL conflict was found to not be\n *   a truly viable alternative. Two-stage parsing cannot be used for inputs where\n *   this situation occurs.\n *\n * @author Sam Harwell\n */\nexport class DiagnosticErrorListener implements ParserErrorListener {\n\n\t/**\n\t * Initializes a new instance of {@link DiagnosticErrorListener}, specifying\n\t * whether all ambiguities or only exact ambiguities are reported.\n\t *\n\t * @param exactOnly `true` to report only exact ambiguities, otherwise\n\t * `false` to report all ambiguities.  Defaults to true.\n\t */\n\tconstructor(protected exactOnly: boolean = true) {\n\t\tthis.exactOnly = exactOnly;\n\t}\n\n\t@Override\n\tpublic syntaxError<T extends Token>(\n\t\t/*@NotNull*/\n\t\trecognizer: Recognizer<T, any>,\n\t\toffendingSymbol: T | undefined,\n\t\tline: number,\n\t\tcharPositionInLine: number,\n\t\t/*@NotNull*/\n\t\tmsg: string,\n\t\te: RecognitionException | undefined): void\n\t{\n\t\t// intentionally empty\n\t}\n\n\t@Override\n\tpublic reportAmbiguity(\n\t\t@NotNull recognizer: Parser,\n\t\t@NotNull dfa: DFA,\n\t\tstartIndex: number,\n\t\tstopIndex: number,\n\t\texact: boolean,\n\t\tambigAlts: BitSet | undefined,\n\t\t@NotNull configs: ATNConfigSet): void {\n\t\tif (this.exactOnly && !exact) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet decision: string = this.getDecisionDescription(recognizer, dfa);\n\t\tlet conflictingAlts: BitSet = this.getConflictingAlts(ambigAlts, configs);\n\t\tlet text: string = recognizer.inputStream.getText(Interval.of(startIndex, stopIndex));\n\t\tlet message: string = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text}'`;\n\t\trecognizer.notifyErrorListeners(message);\n\t}\n\n\t@Override\n\tpublic reportAttemptingFullContext(\n\t\t@NotNull recognizer: Parser,\n\t\t@NotNull dfa: DFA,\n\t\tstartIndex: number,\n\t\tstopIndex: number,\n\t\tconflictingAlts: BitSet | undefined,\n\t\t@NotNull conflictState: SimulatorState): void {\n\t\tlet format: string = \"reportAttemptingFullContext d=%s, input='%s'\";\n\t\tlet decision: string = this.getDecisionDescription(recognizer, dfa);\n\t\tlet text: string = recognizer.inputStream.getText(Interval.of(startIndex, stopIndex));\n\t\tlet message: string = `reportAttemptingFullContext d=${decision}, input='${text}'`;\n\t\trecognizer.notifyErrorListeners(message);\n\t}\n\n\t@Override\n\tpublic reportContextSensitivity(\n\t\t@NotNull recognizer: Parser,\n\t\t@NotNull dfa: DFA,\n\t\tstartIndex: number,\n\t\tstopIndex: number,\n\t\tprediction: number,\n\t\t@NotNull acceptState: SimulatorState): void {\n\t\tlet format: string = \"reportContextSensitivity d=%s, input='%s'\";\n\t\tlet decision: string = this.getDecisionDescription(recognizer, dfa);\n\t\tlet text: string = recognizer.inputStream.getText(Interval.of(startIndex, stopIndex));\n\t\tlet message: string = `reportContextSensitivity d=${decision}, input='${text}'`;\n\t\trecognizer.notifyErrorListeners(message);\n\t}\n\n\tprotected getDecisionDescription(\n\t\t@NotNull recognizer: Parser,\n\t\t@NotNull dfa: DFA): string {\n\t\tlet decision: number = dfa.decision;\n\t\tlet ruleIndex: number = dfa.atnStartState.ruleIndex;\n\n\t\tlet ruleNames: string[] = recognizer.ruleNames;\n\t\tif (ruleIndex < 0 || ruleIndex >= ruleNames.length) {\n\t\t\treturn decision.toString();\n\t\t}\n\n\t\tlet ruleName: string = ruleNames[ruleIndex];\n\t\tif (!ruleName) {\n\t\t\treturn decision.toString();\n\t\t}\n\n\t\treturn `${decision} (${ruleName})`;\n\t}\n\n\t/**\n\t * Computes the set of conflicting or ambiguous alternatives from a\n\t * configuration set, if that information was not already provided by the\n\t * parser.\n\t *\n\t * @param reportedAlts The set of conflicting or ambiguous alternatives, as\n\t * reported by the parser.\n\t * @param configs The conflicting or ambiguous configuration set.\n\t * @returns Returns `reportedAlts` if it is not `undefined`, otherwise\n\t * returns the set of alternatives represented in `configs`.\n\t */\n\t@NotNull\n\tprotected getConflictingAlts(reportedAlts: BitSet | undefined, @NotNull configs: ATNConfigSet): BitSet {\n\t\tif (reportedAlts != null) {\n\t\t\treturn reportedAlts;\n\t\t}\n\n\t\tlet result: BitSet = new BitSet();\n\t\tfor (let config of configs) {\n\t\t\tresult.set(config.alt);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n"]}