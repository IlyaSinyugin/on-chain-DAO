{"version":3,"file":"Token.js","sourceRoot":"","sources":["../../src/Token.ts"],"names":[],"mappings":";AAAA;;;GAGG;;AAKH,2CAAwC;AA8DxC,IAAiB,KAAK,CAkCrB;AAlCD,WAAiB,KAAK;IACR,kBAAY,GAAW,CAAC,CAAC;IAEtC;;OAEG;IACU,aAAO,GAAW,CAAC,CAAC,CAAC;IAErB,yBAAmB,GAAW,CAAC,CAAC;IAEhC,SAAG,GAAW,qBAAS,CAAC,GAAG,CAAC;IAEzC;;;OAGG;IACU,qBAAe,GAAW,CAAC,CAAC;IAEzC;;OAEG;IACU,oBAAc,GAAW,CAAC,CAAC;IAExC;;;;;;;;;OASG;IACU,4BAAsB,GAAW,CAAC,CAAC;AACjD,CAAC,EAlCgB,KAAK,GAAL,aAAK,KAAL,aAAK,QAkCrB","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:57.7862802-07:00\n\nimport { CharStream } from \"./CharStream\";\nimport { IntStream } from \"./IntStream\";\nimport { TokenSource } from \"./TokenSource\";\nimport { TokenStream } from \"./TokenStream\";\n\n/** A token has properties: text, type, line, character position in the line\n *  (so we can ignore tabs), token channel, index, and source from which\n *  we obtained this token.\n */\nexport interface Token {\n\t/**\n\t * Get the text of the token.\n\t */\n\treadonly text: string | undefined;\n\n\t/** Get the token type of the token */\n\treadonly type: number;\n\n\t/** The line number on which the 1st character of this token was matched,\n\t *  line=1..n\n\t */\n\treadonly line: number;\n\n\t/** The index of the first character of this token relative to the\n\t *  beginning of the line at which it occurs, 0..n-1\n\t */\n\treadonly charPositionInLine: number;\n\n\t/** Return the channel this token. Each token can arrive at the parser\n\t *  on a different channel, but the parser only \"tunes\" to a single channel.\n\t *  The parser ignores everything not on DEFAULT_CHANNEL.\n\t */\n\treadonly channel: number;\n\n\t/** An index from 0..n-1 of the token object in the input stream.\n\t *  This must be valid in order to print token streams and\n\t *  use TokenRewriteStream.\n\t *\n\t *  Return -1 to indicate that this token was conjured up since\n\t *  it doesn't have a valid index.\n\t */\n\treadonly tokenIndex: number;\n\n\t/** The starting character index of the token\n\t *  This method is optional; return -1 if not implemented.\n\t */\n\treadonly startIndex: number;\n\n\t/** The last character index of the token.\n\t *  This method is optional; return -1 if not implemented.\n\t */\n\treadonly stopIndex: number;\n\n\t/** Gets the {@link TokenSource} which created this token.\n\t */\n\treadonly tokenSource: TokenSource | undefined;\n\n\t/**\n\t * Gets the {@link CharStream} from which this token was derived.\n\t */\n\treadonly inputStream: CharStream | undefined;\n}\n\nexport namespace Token {\n\texport const INVALID_TYPE: number = 0;\n\n\t/** During lookahead operations, this \"token\" signifies we hit rule end ATN state\n\t *  and did not follow it despite needing to.\n\t */\n\texport const EPSILON: number = -2;\n\n\texport const MIN_USER_TOKEN_TYPE: number = 1;\n\n\texport const EOF: number = IntStream.EOF;\n\n\t/** All tokens go to the parser (unless skip() is called in that rule)\n\t *  on a particular \"channel\".  The parser tunes to a particular channel\n\t *  so that whitespace etc... can go to the parser on a \"hidden\" channel.\n\t */\n\texport const DEFAULT_CHANNEL: number = 0;\n\n\t/** Anything on different channel than DEFAULT_CHANNEL is not parsed\n\t *  by parser.\n\t */\n\texport const HIDDEN_CHANNEL: number = 1;\n\n\t/**\n\t * This is the minimum constant value which can be assigned to a\n\t * user-defined token channel.\n\t *\n\t * The non-negative numbers less than {@link #MIN_USER_CHANNEL_VALUE} are\n\t * assigned to the predefined channels {@link #DEFAULT_CHANNEL} and\n\t * {@link #HIDDEN_CHANNEL}.\n\t *\n\t * @see `Token.channel`\n\t */\n\texport const MIN_USER_CHANNEL_VALUE: number = 2;\n}\n"]}