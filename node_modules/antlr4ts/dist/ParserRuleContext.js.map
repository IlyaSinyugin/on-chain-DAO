{"version":3,"file":"ParserRuleContext.js","sourceRoot":"","sources":["../../src/ParserRuleContext.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:56.6285494-07:00\nimport { ErrorNode } from \"./tree/ErrorNode\";\nimport { Interval } from \"./misc/Interval\";\nimport { Override } from \"./Decorators\";\nimport { Parser } from \"./Parser\";\nimport { ParseTree } from \"./tree/ParseTree\";\nimport { ParseTreeListener } from \"./tree/ParseTreeListener\";\nimport { RecognitionException } from \"./RecognitionException\";\nimport { RuleContext } from \"./RuleContext\";\nimport { TerminalNode } from \"./tree/TerminalNode\";\nimport { Token } from \"./Token\";\n\n/** A rule invocation record for parsing.\n *\n *  Contains all of the information about the current rule not stored in the\n *  RuleContext. It handles parse tree children list, Any ATN state\n *  tracing, and the default values available for rule invocations:\n *  start, stop, rule index, current alt number.\n *\n *  Subclasses made for each rule and grammar track the parameters,\n *  return values, locals, and labels specific to that rule. These\n *  are the objects that are returned from rules.\n *\n *  Note text is not an actual field of a rule return value; it is computed\n *  from start and stop using the input stream's toString() method.  I\n *  could add a ctor to this so that we can pass in and store the input\n *  stream, but I'm not sure we want to do that.  It would seem to be undefined\n *  to get the .text property anyway if the rule matches tokens from multiple\n *  input streams.\n *\n *  I do not use getters for fields of objects that are used simply to\n *  group values such as this aggregate.  The getters/setters are there to\n *  satisfy the superclass interface.\n */\nexport class ParserRuleContext extends RuleContext {\n\tprivate static readonly EMPTY: ParserRuleContext = new ParserRuleContext();\n\n\t/** If we are debugging or building a parse tree for a visitor,\n\t *  we need to track all of the tokens and rule invocations associated\n\t *  with this rule's context. This is empty for parsing w/o tree constr.\n\t *  operation because we don't the need to track the details about\n\t *  how we parse this rule.\n\t */\n\tpublic children?: ParseTree[];\n\n\t/** For debugging/tracing purposes, we want to track all of the nodes in\n\t *  the ATN traversed by the parser for a particular rule.\n\t *  This list indicates the sequence of ATN nodes used to match\n\t *  the elements of the children list. This list does not include\n\t *  ATN nodes and other rules used to match rule invocations. It\n\t *  traces the rule invocation node itself but nothing inside that\n\t *  other rule's ATN submachine.\n\t *\n\t *  There is NOT a one-to-one correspondence between the children and\n\t *  states list. There are typically many nodes in the ATN traversed\n\t *  for each element in the children list. For example, for a rule\n\t *  invocation there is the invoking state and the following state.\n\t *\n\t *  The parser state property updates field s and adds it to this list\n\t *  if we are debugging/tracing.\n\t *\n\t *  This does not trace states visited during prediction.\n\t */\n//\tpublic Array<number> states;\n\n\tpublic _start: Token;\n\tpublic _stop: Token | undefined;\n\n\t/**\n\t * The exception that forced this rule to return. If the rule successfully\n\t * completed, this is `undefined`.\n\t */\n\tpublic exception?: RecognitionException;\n\n\tconstructor();\n\tconstructor(parent: ParserRuleContext | undefined, invokingStateNumber: number);\n\tconstructor(parent?: ParserRuleContext, invokingStateNumber?: number) {\n\t\tif (invokingStateNumber == null) {\n\t\t\tsuper();\n\t\t} else {\n\t\t\tsuper(parent, invokingStateNumber);\n\t\t}\n\t}\n\n\tpublic static emptyContext(): ParserRuleContext {\n\t\treturn ParserRuleContext.EMPTY;\n\t}\n\n\t/**\n\t * COPY a ctx (I'm deliberately not using copy constructor) to avoid\n\t * confusion with creating node with parent. Does not copy children\n\t * (except error leaves).\n\t *\n\t * This is used in the generated parser code to flip a generic XContext\n\t * node for rule X to a YContext for alt label Y. In that sense, it is not\n\t * really a generic copy function.\n\t *\n\t * If we do an error sync() at start of a rule, we might add error nodes\n\t * to the generic XContext so this function must copy those nodes to the\n\t * YContext as well else they are lost!\n\t */\n\tpublic copyFrom(ctx: ParserRuleContext): void {\n\t\tthis._parent = ctx._parent;\n\t\tthis.invokingState = ctx.invokingState;\n\n\t\tthis._start = ctx._start;\n\t\tthis._stop = ctx._stop;\n\n\t\t// copy any error nodes to alt label node\n\t\tif (ctx.children) {\n\t\t\tthis.children = [];\n\t\t\t// reset parent pointer for any error nodes\n\t\t\tfor (let child of ctx.children) {\n\t\t\t\tif (child instanceof ErrorNode) {\n\t\t\t\t\tthis.addChild(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Double dispatch methods for listeners\n\n\tpublic enterRule(listener: ParseTreeListener): void {\n\t\t// intentionally empty\n\t}\n\tpublic exitRule(listener: ParseTreeListener): void {\n\t\t// intentionally empty\n\t}\n\n\t/** Add a parse tree node to this as a child.  Works for\n\t *  internal and leaf nodes. Does not set parent link;\n\t *  other add methods must do that. Other addChild methods\n\t *  call this.\n\t *\n\t *  We cannot set the parent pointer of the incoming node\n\t *  because the existing interfaces do not have a setParent()\n\t *  method and I don't want to break backward compatibility for this.\n\t *\n\t *  @since 4.7\n\t */\n\tpublic addAnyChild<T extends ParseTree>(t: T): T {\n\t\tif (!this.children) {\n\t\t\tthis.children = [t];\n\t\t} else {\n\t\t\tthis.children.push(t);\n\t\t}\n\n\t\treturn t;\n\t}\n\n\t/** Add a token leaf node child and force its parent to be this node. */\n\tpublic addChild(t: TerminalNode): void;\n\tpublic addChild(ruleInvocation: RuleContext): void;\n\t/**\n\t * Add a child to this node based upon matchedToken. It\n\t * creates a TerminalNodeImpl rather than using\n\t * {@link Parser#createTerminalNode(ParserRuleContext, Token)}. I'm leaving this\n\t * in for compatibility but the parser doesn't use this anymore.\n\t *\n\t * @deprecated Use another overload instead.\n\t */\n\tpublic addChild(matchedToken: Token): TerminalNode;\n\tpublic addChild(t: TerminalNode | RuleContext | Token): TerminalNode | void {\n\t\tlet result: TerminalNode | void;\n\t\tif (t instanceof TerminalNode) {\n\t\t\tt.setParent(this);\n\t\t\tthis.addAnyChild(t);\n\t\t\treturn;\n\t\t} else if (t instanceof RuleContext) {\n\t\t\t// Does not set parent link\n\t\t\tthis.addAnyChild(t);\n\t\t\treturn;\n\t\t} else {\n\t\t\t// Deprecated code path\n\t\t\tt = new TerminalNode(t);\n\t\t\tthis.addAnyChild(t);\n\t\t\tt.setParent(this);\n\t\t\treturn t;\n\t\t}\n\t}\n\n\t/** Add an error node child and force its parent to be this node.\n\t *\n\t * @since 4.7\n\t */\n\tpublic addErrorNode(errorNode: ErrorNode): ErrorNode;\n\n\t/**\n\t * Add a child to this node based upon badToken. It\n\t * creates a ErrorNode rather than using\n\t * {@link Parser#createErrorNode(ParserRuleContext, Token)}. I'm leaving this\n\t * in for compatibility but the parser doesn't use this anymore.\n\t *\n\t * @deprecated Use another overload instead.\n\t */\n\tpublic addErrorNode(badToken: Token): ErrorNode;\n\tpublic addErrorNode(node: ErrorNode | Token): ErrorNode {\n\t\tif (node instanceof ErrorNode) {\n\t\t\tconst errorNode: ErrorNode = node;\n\t\t\terrorNode.setParent(this);\n\t\t\treturn this.addAnyChild(errorNode);\n\t\t} else {\n\t\t\t// deprecated path\n\t\t\tconst badToken: Token = node;\n\t\t\tlet t = new ErrorNode(badToken);\n\t\t\tthis.addAnyChild(t);\n\t\t\tt.setParent(this);\n\t\t\treturn t;\n\t\t}\n\t}\n\n//\tpublic void trace(int s) {\n//\t\tif ( states==null ) states = new ArrayList<Integer>();\n//\t\tstates.add(s);\n//\t}\n\n\t/** Used by enterOuterAlt to toss out a RuleContext previously added as\n\t *  we entered a rule. If we have # label, we will need to remove\n\t *  generic ruleContext object.\n\t */\n\tpublic removeLastChild(): void {\n\t\tif (this.children) {\n\t\t\tthis.children.pop();\n\t\t}\n\t}\n\n\t@Override\n\t/** Override to make type more specific */\n\tget parent(): ParserRuleContext | undefined {\n\t\tlet parent = super.parent;\n\t\tif (parent === undefined || parent instanceof ParserRuleContext) {\n\t\t\treturn parent;\n\t\t}\n\n\t\tthrow new TypeError(\"Invalid parent type for ParserRuleContext\");\n\t}\n\n\tpublic getChild(i: number): ParseTree;\n\tpublic getChild<T extends ParseTree>(i: number, ctxType: { new (...args: any[]): T; }): T;\n\t// Note: in TypeScript, order or arguments reversed\n\tpublic getChild<T extends ParseTree>(i: number, ctxType?: { new (...args: any[]): T; }): ParseTree {\n\t\tif (!this.children || i < 0 || i >= this.children.length) {\n\t\t\tthrow new RangeError(\"index parameter must be between >= 0 and <= number of children.\");\n\t\t}\n\n\t\tif (ctxType == null) {\n\t\t\treturn this.children[i];\n\t\t}\n\n\t\tlet result = this.tryGetChild(i, ctxType);\n\t\tif (result === undefined) {\n\t\t\tthrow new Error(\"The specified node does not exist\");\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic tryGetChild<T extends ParseTree>(i: number, ctxType: { new (...args: any[]): T; }): T | undefined {\n\t\tif (!this.children || i < 0 || i >= this.children.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet j: number = -1; // what node with ctxType have we found?\n\t\tfor (let o of this.children) {\n\t\t\tif (o instanceof ctxType) {\n\t\t\t\tj++;\n\t\t\t\tif (j === i) {\n\t\t\t\t\treturn o;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tpublic getToken(ttype: number, i: number): TerminalNode {\n\t\tlet result = this.tryGetToken(ttype, i);\n\t\tif (result === undefined) {\n\t\t\tthrow new Error(\"The specified token does not exist\");\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic tryGetToken(ttype: number, i: number): TerminalNode | undefined {\n\t\tif (!this.children || i < 0 || i >= this.children.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet j: number = -1; // what token with ttype have we found?\n\t\tfor (let o of this.children) {\n\t\t\tif (o instanceof TerminalNode) {\n\t\t\t\tlet symbol: Token = o.symbol;\n\t\t\t\tif (symbol.type === ttype) {\n\t\t\t\t\tj++;\n\t\t\t\t\tif (j === i) {\n\t\t\t\t\t\treturn o;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tpublic getTokens(ttype: number): TerminalNode[] {\n\t\tlet tokens: TerminalNode[] = [];\n\n\t\tif (!this.children) {\n\t\t\treturn tokens;\n\t\t}\n\n\t\tfor (let o of this.children) {\n\t\t\tif (o instanceof TerminalNode) {\n\t\t\t\tlet symbol = o.symbol;\n\t\t\t\tif (symbol.type === ttype) {\n\t\t\t\t\ttokens.push(o);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tokens;\n\t}\n\n\tget ruleContext(): this {\n\t\treturn this;\n\t}\n\n\t// NOTE: argument order change from Java version\n\tpublic getRuleContext<T extends ParserRuleContext>(i: number, ctxType: { new (...args: any[]): T; }): T {\n\t\treturn this.getChild(i, ctxType);\n\t}\n\n\tpublic tryGetRuleContext<T extends ParserRuleContext>(i: number, ctxType: { new (...args: any[]): T; }): T | undefined {\n\t\treturn this.tryGetChild(i, ctxType);\n\t}\n\n\tpublic getRuleContexts<T extends ParserRuleContext>(ctxType: { new (...args: any[]): T; }): T[] {\n\t\tlet contexts: T[] = [];\n\t\tif (!this.children) {\n\t\t\treturn contexts;\n\t\t}\n\n\t\tfor (let o of this.children) {\n\t\t\tif (o instanceof ctxType) {\n\t\t\t\tcontexts.push(o);\n\t\t\t}\n\t\t}\n\n\t\treturn contexts;\n\t}\n\n\t@Override\n\tget childCount() {\n\t\treturn this.children ? this.children.length : 0;\n\t}\n\n\t@Override\n\tget sourceInterval(): Interval {\n\t\tif (!this._start) {\n\t\t\treturn Interval.INVALID;\n\t\t}\n\t\tif (!this._stop || this._stop.tokenIndex < this._start.tokenIndex) {\n\t\t\treturn Interval.of(this._start.tokenIndex, this._start.tokenIndex - 1); // empty\n\t\t}\n\t\treturn Interval.of(this._start.tokenIndex, this._stop.tokenIndex);\n\t}\n\n\t/**\n\t * Get the initial token in this context.\n\t * Note that the range from start to stop is inclusive, so for rules that do not consume anything\n\t * (for example, zero length or error productions) this token may exceed stop.\n\t */\n\tget start(): Token { return this._start; }\n\t/**\n\t * Get the final token in this context.\n\t * Note that the range from start to stop is inclusive, so for rules that do not consume anything\n\t * (for example, zero length or error productions) this token may precede start.\n\t */\n\tget stop(): Token | undefined { return this._stop; }\n\n\t/** Used for rule context info debugging during parse-time, not so much for ATN debugging */\n\tpublic toInfoString(recognizer: Parser): string {\n\t\tlet rules: string[] =\n\t\t\trecognizer.getRuleInvocationStack(this).reverse();\n\t\treturn \"ParserRuleContext\" + rules + \"{\" +\n\t\t\t\"start=\" + this._start +\n\t\t\t\", stop=\" + this._stop +\n\t\t\t\"}\";\n\t}\n}\n"]}