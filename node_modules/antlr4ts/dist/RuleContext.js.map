{"version":3,"file":"RuleContext.js","sourceRoot":"","sources":["../../src/RuleContext.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:57.3490837-07:00\n\nimport { ATN } from \"./atn/ATN\";\nimport { Parser } from \"./Parser\";\nimport { Recognizer } from \"./Recognizer\";\nimport { RuleNode } from \"./tree/RuleNode\";\nimport { ParseTree } from \"./tree/ParseTree\";\nimport { Interval } from \"./misc/Interval\";\nimport { Override } from \"./Decorators\";\nimport { Trees } from \"./tree/Trees\";\nimport { ParseTreeVisitor } from \"./tree/ParseTreeVisitor\";\nimport { ParserRuleContext } from \"./ParserRuleContext\";\n\n/** A rule context is a record of a single rule invocation.\n *\n *  We form a stack of these context objects using the parent\n *  pointer. A parent pointer of `undefined` indicates that the current\n *  context is the bottom of the stack. The ParserRuleContext subclass\n *  as a children list so that we can turn this data structure into a\n *  tree.\n *\n *  The root node always has a `undefined` pointer and invokingState of -1.\n *\n *  Upon entry to parsing, the first invoked rule function creates a\n *  context object (a subclass specialized for that rule such as\n *  SContext) and makes it the root of a parse tree, recorded by field\n *  Parser._ctx.\n *\n *  public final SContext s() throws RecognitionException {\n *      SContext _localctx = new SContext(_ctx, state); <-- create new node\n *      enterRule(_localctx, 0, RULE_s);                     <-- push it\n *      ...\n *      exitRule();                                          <-- pop back to _localctx\n *      return _localctx;\n *  }\n *\n *  A subsequent rule invocation of r from the start rule s pushes a\n *  new context object for r whose parent points at s and use invoking\n *  state is the state with r emanating as edge label.\n *\n *  The invokingState fields from a context object to the root\n *  together form a stack of rule indication states where the root\n *  (bottom of the stack) has a -1 sentinel value. If we invoke start\n *  symbol s then call r1, which calls r2, the  would look like\n *  this:\n *\n *     SContext[-1]   <- root node (bottom of the stack)\n *     R1Context[p]   <- p in rule s called r1\n *     R2Context[q]   <- q in rule r1 called r2\n *\n *  So the top of the stack, _ctx, represents a call to the current\n *  rule and it holds the return address from another rule that invoke\n *  to this rule. To invoke a rule, we must always have a current context.\n *\n *  The parent contexts are useful for computing lookahead sets and\n *  getting error information.\n *\n *  These objects are used during parsing and prediction.\n *  For the special case of parsers, we use the subclass\n *  ParserRuleContext.\n *\n *  @see ParserRuleContext\n */\nexport class RuleContext extends RuleNode {\n\tpublic _parent: RuleContext | undefined;\n\tpublic invokingState: number;\n\n\tconstructor();\n\tconstructor(parent: RuleContext | undefined, invokingState: number);\n\tconstructor(parent?: RuleContext, invokingState?: number) {\n\t\tsuper();\n\t\tthis._parent = parent;\n\t\tthis.invokingState = invokingState != null ? invokingState : -1;\n\t}\n\n\tpublic static getChildContext(parent: RuleContext, invokingState: number): RuleContext {\n\t\treturn new RuleContext(parent, invokingState);\n\t}\n\n\tpublic depth(): number {\n\t\tlet n = 0;\n\t\tlet p: RuleContext | undefined = this;\n\t\twhile (p) {\n\t\t\tp = p._parent;\n\t\t\tn++;\n\t\t}\n\t\treturn n;\n\t}\n\n\t/** A context is empty if there is no invoking state; meaning nobody called\n\t *  current context.\n\t */\n\tget isEmpty(): boolean {\n\t\treturn this.invokingState === -1;\n\t}\n\n\t// satisfy the ParseTree / SyntaxTree interface\n\n\t@Override\n\tget sourceInterval(): Interval {\n\t\treturn Interval.INVALID;\n\t}\n\n\t@Override\n\tget ruleContext(): RuleContext { return this; }\n\n\t@Override\n\tget parent(): RuleContext | undefined { return this._parent; }\n\n\t/** @since 4.7. {@see ParseTree#setParent} comment */\n\t@Override\n\tpublic setParent(parent: RuleContext): void {\n\t\tthis._parent = parent;\n\t}\n\n\t@Override\n\tget payload(): RuleContext { return this; }\n\n\t/** Return the combined text of all child nodes. This method only considers\n\t *  tokens which have been added to the parse tree.\n\t *\n\t *  Since tokens on hidden channels (e.g. whitespace or comments) are not\n\t *  added to the parse trees, they will not appear in the output of this\n\t *  method.\n\t */\n\t@Override\n\tget text(): string {\n\t\tif (this.childCount === 0) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tlet builder = \"\";\n\t\tfor (let i = 0; i < this.childCount; i++) {\n\t\t\tbuilder += this.getChild(i).text;\n\t\t}\n\n\t\treturn builder.toString();\n\t}\n\n\tget ruleIndex(): number { return -1; }\n\n\t/** For rule associated with this parse tree internal node, return\n\t *  the outer alternative number used to match the input. Default\n\t *  implementation does not compute nor store this alt num. Create\n\t *  a subclass of ParserRuleContext with backing field and set\n\t *  option contextSuperClass.\n\t *  to set it.\n\t *\n\t *  @since 4.5.3\n\t */\n\tget altNumber(): number { return ATN.INVALID_ALT_NUMBER; }\n\n\t/** Set the outer alternative number for this context node. Default\n\t *  implementation does nothing to avoid backing field overhead for\n\t *  trees that don't need it.  Create\n\t *  a subclass of ParserRuleContext with backing field and set\n\t *  option contextSuperClass.\n\t *\n\t *  @since 4.5.3\n\t */\n\tset altNumber(altNumber: number) {\n\t\t// intentionally ignored by the base implementation\n\t}\n\n\t@Override\n\tpublic getChild(i: number): ParseTree {\n\t\tthrow new RangeError(\"i must be greater than or equal to 0 and less than childCount\");\n\t}\n\n\t@Override\n\tget childCount(): number {\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic accept<T>(visitor: ParseTreeVisitor<T>): T {\n\t\treturn visitor.visitChildren(this);\n\t}\n\n\t/** Print out a whole tree, not just a node, in LISP format\n\t *  (root child1 .. childN). Print just a node if this is a leaf.\n\t *  We have to know the recognizer so we can get rule names.\n\t */\n\tpublic toStringTree(recog: Parser): string;\n\n\t/** Print out a whole tree, not just a node, in LISP format\n\t *  (root child1 .. childN). Print just a node if this is a leaf.\n\t */\n\tpublic toStringTree(ruleNames: string[] | undefined): string;\n\n\tpublic toStringTree(): string;\n\n\t@Override\n\tpublic toStringTree(recog?: Parser | string[]): string {\n\t\treturn Trees.toStringTree(this, recog);\n\t}\n\n\tpublic toString(): string;\n\tpublic toString(recog: Recognizer<any, any> | undefined): string;\n\tpublic toString(ruleNames: string[] | undefined): string;\n\n\t// // recog undefined unless ParserRuleContext, in which case we use subclass toString(...)\n\tpublic toString(recog: Recognizer<any, any> | undefined, stop: RuleContext | undefined): string;\n\n\tpublic toString(ruleNames: string[] | undefined, stop: RuleContext | undefined): string;\n\n\tpublic toString(\n\t\targ1?: Recognizer<any, any> | string[],\n\t\tstop?: RuleContext)\n\t\t: string {\n\t\tconst ruleNames = (arg1 instanceof Recognizer) ? arg1.ruleNames : arg1;\n\t\tstop = stop || ParserRuleContext.emptyContext();\n\n\t\tlet buf = \"\";\n\t\tlet p: RuleContext | undefined = this;\n\t\tbuf += (\"[\");\n\t\twhile (p && p !== stop) {\n\t\t\tif (!ruleNames) {\n\t\t\t\tif (!p.isEmpty) {\n\t\t\t\t\tbuf += (p.invokingState);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet ruleIndex: number = p.ruleIndex;\n\t\t\t\tlet ruleName: string = (ruleIndex >= 0 && ruleIndex < ruleNames.length)\n\t\t\t\t\t? ruleNames[ruleIndex] : ruleIndex.toString();\n\t\t\t\tbuf += (ruleName);\n\t\t\t}\n\n\t\t\tif (p._parent && (ruleNames || !p._parent.isEmpty)) {\n\t\t\t\tbuf += (\" \");\n\t\t\t}\n\n\t\t\tp = p._parent;\n\t\t}\n\n\t\tbuf += (\"]\");\n\t\treturn buf.toString();\n\t}\n}\n"]}