{"version":3,"file":"Lexer.js","sourceRoot":"","sources":["../../src/Lexer.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:51.7913318-07:00\n\nimport { ANTLRErrorListener } from \"./ANTLRErrorListener\";\nimport { CharStream } from \"./CharStream\";\nimport { CommonTokenFactory } from \"./CommonTokenFactory\";\nimport { IntegerStack } from \"./misc/IntegerStack\";\nimport { Interval } from \"./misc/Interval\";\nimport { IntStream } from \"./IntStream\";\nimport { LexerATNSimulator } from \"./atn/LexerATNSimulator\";\nimport { LexerNoViableAltException } from \"./LexerNoViableAltException\";\nimport { Override } from \"./Decorators\";\nimport { RecognitionException } from \"./RecognitionException\";\nimport { Recognizer } from \"./Recognizer\";\nimport { Token } from \"./Token\";\nimport { TokenFactory } from \"./TokenFactory\";\nimport { TokenSource } from \"./TokenSource\";\n\n/** A lexer is recognizer that draws input symbols from a character stream.\n *  lexer grammars result in a subclass of this object. A Lexer object\n *  uses simplified match() and error recovery mechanisms in the interest\n *  of speed.\n */\nexport abstract class Lexer extends Recognizer<number, LexerATNSimulator>\n\timplements TokenSource {\n\tpublic static readonly DEFAULT_MODE: number = 0;\n\tpublic static readonly MORE: number = -2;\n\tpublic static readonly SKIP: number = -3;\n\n\tstatic get DEFAULT_TOKEN_CHANNEL(): number {\n\t\treturn Token.DEFAULT_CHANNEL;\n\t}\n\n\tstatic get HIDDEN(): number {\n\t\treturn Token.HIDDEN_CHANNEL;\n\t}\n\n\tpublic static readonly MIN_CHAR_VALUE: number = 0x0000;\n\tpublic static readonly MAX_CHAR_VALUE: number = 0x10FFFF;\n\n\tpublic _input: CharStream;\n\n\tprotected _tokenFactorySourcePair: { source: TokenSource, stream: CharStream };\n\n\t/** How to create token objects */\n\tprotected _factory: TokenFactory = CommonTokenFactory.DEFAULT;\n\n\t/** The goal of all lexer rules/methods is to create a token object.\n\t *  This is an instance variable as multiple rules may collaborate to\n\t *  create a single token.  nextToken will return this object after\n\t *  matching lexer rule(s).  If you subclass to allow multiple token\n\t *  emissions, then set this to the last token to be matched or\n\t *  something non-undefined so that the auto token emit mechanism will not\n\t *  emit another token.\n\t */\n\tpublic _token: Token | undefined;\n\n\t/** What character index in the stream did the current token start at?\n\t *  Needed, for example, to get the text for current token.  Set at\n\t *  the start of nextToken.\n\t */\n\tpublic _tokenStartCharIndex: number = -1;\n\n\t/** The line on which the first character of the token resides */\n\tpublic _tokenStartLine: number = 0;\n\n\t/** The character position of first character within the line */\n\tpublic _tokenStartCharPositionInLine: number = 0;\n\n\t/** Once we see EOF on char stream, next token will be EOF.\n\t *  If you have DONE : EOF ; then you see DONE EOF.\n\t */\n\tpublic _hitEOF: boolean = false;\n\n\t/** The channel number for the current token */\n\tpublic _channel: number = 0;\n\n\t/** The token type for the current token */\n\tpublic _type: number = 0;\n\n\tpublic readonly _modeStack: IntegerStack = new IntegerStack();\n\tpublic _mode: number = Lexer.DEFAULT_MODE;\n\n\t/** You can set the text for the current token to override what is in\n\t *  the input char buffer.  Set `text` or can set this instance var.\n\t */\n\tpublic _text: string | undefined;\n\n\tconstructor(input: CharStream) {\n\t\tsuper();\n\t\tthis._input = input;\n\t\tthis._tokenFactorySourcePair = { source: this, stream: input };\n\t}\n\n\tpublic reset(): void;\n\tpublic reset(resetInput: boolean): void;\n\tpublic reset(resetInput?: boolean): void {\n\t\t// wack Lexer state variables\n\t\tif (resetInput === undefined || resetInput) {\n\t\t\tthis._input.seek(0); // rewind the input\n\t\t}\n\n\t\tthis._token = undefined;\n\t\tthis._type = Token.INVALID_TYPE;\n\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\t\tthis._tokenStartCharIndex = -1;\n\t\tthis._tokenStartCharPositionInLine = -1;\n\t\tthis._tokenStartLine = -1;\n\t\tthis._text = undefined;\n\n\t\tthis._hitEOF = false;\n\t\tthis._mode = Lexer.DEFAULT_MODE;\n\t\tthis._modeStack.clear();\n\n\t\tthis.interpreter.reset();\n\t}\n\n\t/** Return a token from this source; i.e., match a token on the char\n\t *  stream.\n\t */\n\t@Override\n\tpublic nextToken(): Token {\n\t\tif (this._input == null) {\n\t\t\tthrow new Error(\"nextToken requires a non-null input stream.\");\n\t\t}\n\n\t\t// Mark start location in char stream so unbuffered streams are\n\t\t// guaranteed at least have text of current token\n\t\tlet tokenStartMarker: number = this._input.mark();\n\t\ttry {\n\t\t\touter:\n\t\t\twhile (true) {\n\t\t\t\tif (this._hitEOF) {\n\t\t\t\t\treturn this.emitEOF();\n\t\t\t\t}\n\n\t\t\t\tthis._token = undefined;\n\t\t\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\t\t\t\tthis._tokenStartCharIndex = this._input.index;\n\t\t\t\tthis._tokenStartCharPositionInLine = this.interpreter.charPositionInLine;\n\t\t\t\tthis._tokenStartLine = this.interpreter.line;\n\t\t\t\tthis._text = undefined;\n\t\t\t\tdo {\n\t\t\t\t\tthis._type = Token.INVALID_TYPE;\n//\t\t\t\tSystem.out.println(\"nextToken line \"+tokenStartLine+\" at \"+((char)input.LA(1))+\n//\t\t\t\t\t\t\t\t   \" in mode \"+mode+\n//\t\t\t\t\t\t\t\t   \" at index \"+input.index);\n\t\t\t\t\tlet ttype: number;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tttype = this.interpreter.match(this._input, this._mode);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\tif (e instanceof LexerNoViableAltException) {\n\t\t\t\t\t\t\tthis.notifyListeners(e);\t\t// report error\n\t\t\t\t\t\t\tthis.recover(e);\n\t\t\t\t\t\t\tttype = Lexer.SKIP;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this._input.LA(1) === IntStream.EOF) {\n\t\t\t\t\t\tthis._hitEOF = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type === Token.INVALID_TYPE) {\n\t\t\t\t\t\tthis._type = ttype;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type === Lexer.SKIP) {\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t} while (this._type === Lexer.MORE);\n\t\t\t\tif (this._token == null) {\n\t\t\t\t\treturn this.emit();\n\t\t\t\t}\n\t\t\t\treturn this._token;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t// make sure we release marker after match or\n\t\t\t// unbuffered char stream will keep buffering\n\t\t\tthis._input.release(tokenStartMarker);\n\t\t}\n\t}\n\n\t/** Instruct the lexer to skip creating a token for current lexer rule\n\t *  and look for another token.  nextToken() knows to keep looking when\n\t *  a lexer rule finishes with token set to SKIP_TOKEN.  Recall that\n\t *  if token==undefined at end of any token rule, it creates one for you\n\t *  and emits it.\n\t */\n\tpublic skip(): void {\n\t\tthis._type = Lexer.SKIP;\n\t}\n\n\tpublic more(): void {\n\t\tthis._type = Lexer.MORE;\n\t}\n\n\tpublic mode(m: number): void {\n\t\tthis._mode = m;\n\t}\n\n\tpublic pushMode(m: number): void {\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"pushMode \" + m);\n\t\t}\n\t\tthis._modeStack.push(this._mode);\n\t\tthis.mode(m);\n\t}\n\n\tpublic popMode(): number {\n\t\tif (this._modeStack.isEmpty) {\n\t\t\tthrow new Error(\"EmptyStackException\");\n\t\t}\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"popMode back to \" + this._modeStack.peek());\n\t\t}\n\t\tthis.mode(this._modeStack.pop());\n\t\treturn this._mode;\n\t}\n\n\t@Override\n\tget tokenFactory(): TokenFactory {\n\t\treturn this._factory;\n\t}\n\n\t// @Override\n\tset tokenFactory(factory: TokenFactory) {\n\t\tthis._factory = factory;\n\t}\n\n\t@Override\n\tget inputStream(): CharStream {\n\t\treturn this._input;\n\t}\n\n\t/** Set the char stream and reset the lexer */\n\tset inputStream(input: CharStream) {\n\t\tthis.reset(false);\n\t\tthis._input = input;\n\t\tthis._tokenFactorySourcePair = { source: this, stream: this._input };\n\t}\n\n\t@Override\n\tget sourceName(): string {\n\t\treturn this._input.sourceName;\n\t}\n\n\n\t/** The standard method called to automatically emit a token at the\n\t *  outermost lexical rule.  The token object should point into the\n\t *  char buffer start..stop.  If there is a text override in 'text',\n\t *  use that to set the token's text.  Override this method to emit\n\t *  custom Token objects or provide a new factory.\n\t */\n\tpublic emit(token: Token): Token;\n\n\t/** By default does not support multiple emits per nextToken invocation\n\t *  for efficiency reasons.  Subclass and override this method, nextToken,\n\t *  and getToken (to push tokens into a list and pull from that list\n\t *  rather than a single variable as this implementation does).\n\t */\n\tpublic emit(): Token;\n\n\tpublic emit(token?: Token): Token {\n\t\tif (!token) {\n\t\t\ttoken = this._factory.create(\n\t\t\t\tthis._tokenFactorySourcePair, this._type, this._text, this._channel,\n\t\t\t\tthis._tokenStartCharIndex, this.charIndex - 1, this._tokenStartLine,\n\t\t\t\tthis._tokenStartCharPositionInLine);\n\t\t}\n\t\tthis._token = token;\n\t\treturn token;\n\t}\n\n\tpublic emitEOF(): Token {\n\t\tlet cpos: number = this.charPositionInLine;\n\t\tlet line: number = this.line;\n\t\tlet eof: Token = this._factory.create(\n\t\t\tthis._tokenFactorySourcePair, Token.EOF, undefined,\n\t\t\tToken.DEFAULT_CHANNEL, this._input.index, this._input.index - 1,\n\t\t\tline, cpos);\n\t\tthis.emit(eof);\n\t\treturn eof;\n\t}\n\n\t@Override\n\tget line(): number {\n\t\treturn this.interpreter.line;\n\t}\n\n\tset line(line: number) {\n\t\tthis.interpreter.line = line;\n\t}\n\n\t@Override\n\tget charPositionInLine(): number {\n\t\treturn this.interpreter.charPositionInLine;\n\t}\n\n\tset charPositionInLine(charPositionInLine: number) {\n\t\tthis.interpreter.charPositionInLine = charPositionInLine;\n\t}\n\n\t/** What is the index of the current character of lookahead? */\n\tget charIndex(): number {\n\t\treturn this._input.index;\n\t}\n\n\t/** Return the text matched so far for the current token or any\n\t *  text override.\n\t */\n\tget text(): string {\n\t\tif (this._text != null) {\n\t\t\treturn this._text;\n\t\t}\n\t\treturn this.interpreter.getText(this._input);\n\t}\n\n\t/** Set the complete text of this token; it wipes any previous\n\t *  changes to the text.\n\t */\n\tset text(text: string) {\n\t\tthis._text = text;\n\t}\n\n\t/** Override if emitting multiple tokens. */\n\tget token(): Token | undefined { return this._token; }\n\n\tset token(_token: Token | undefined) {\n\t\tthis._token = _token;\n\t}\n\n\tset type(ttype: number) {\n\t\tthis._type = ttype;\n\t}\n\n\tget type(): number {\n\t\treturn this._type;\n\t}\n\n\tset channel(channel: number) {\n\t\tthis._channel = channel;\n\t}\n\n\tget channel(): number {\n\t\treturn this._channel;\n\t}\n\n\tpublic abstract readonly channelNames: string[];\n\n\tpublic abstract readonly modeNames: string[];\n\n\t/** Return a list of all Token objects in input char stream.\n\t *  Forces load of all tokens. Does not include EOF token.\n\t */\n\tpublic getAllTokens(): Token[] {\n\t\tlet tokens: Token[] = [];\n\t\tlet t: Token = this.nextToken();\n\t\twhile (t.type !== Token.EOF) {\n\t\t\ttokens.push(t);\n\t\t\tt = this.nextToken();\n\t\t}\n\t\treturn tokens;\n\t}\n\n\tpublic notifyListeners(e: LexerNoViableAltException): void {\n\t\tlet text: string = this._input.getText(\n\t\t\tInterval.of(this._tokenStartCharIndex, this._input.index));\n\t\tlet msg: string = \"token recognition error at: '\" +\n\t\t\tthis.getErrorDisplay(text) + \"'\";\n\n\t\tlet listener: ANTLRErrorListener<number> = this.getErrorListenerDispatch();\n\t\tif (listener.syntaxError) {\n\t\t\tlistener.syntaxError(this, undefined, this._tokenStartLine, this._tokenStartCharPositionInLine, msg, e);\n\t\t}\n\t}\n\n\tpublic getErrorDisplay(s: string | number): string {\n\t\tif (typeof s === \"number\") {\n\t\t\tswitch (s) {\n\t\t\tcase Token.EOF:\n\t\t\t\treturn \"<EOF>\";\n\t\t\tcase 0x0a:\n\t\t\t\treturn \"\\\\n\";\n\t\t\tcase 0x09:\n\t\t\t\treturn \"\\\\t\";\n\t\t\tcase 0x0d:\n\t\t\t\treturn \"\\\\r\";\n\t\t\t}\n\t\t\treturn String.fromCharCode(s);\n\t\t}\n\t\treturn s.replace(/\\n/g, \"\\\\n\")\n\t\t\t.replace(/\\t/g, \"\\\\t\")\n\t\t\t.replace(/\\r/g, \"\\\\r\");\n\t}\n\n\tpublic getCharErrorDisplay(c: number): string {\n\t\tlet s: string = this.getErrorDisplay(c);\n\t\treturn \"'\" + s + \"'\";\n\t}\n\n\t/** Lexers can normally match any char in it's vocabulary after matching\n\t *  a token, so do the easy thing and just kill a character and hope\n\t *  it all works out.  You can instead use the rule invocation stack\n\t *  to do sophisticated error recovery if you are in a fragment rule.\n\t */\n\tpublic recover(re: RecognitionException): void;\n\tpublic recover(re: LexerNoViableAltException): void;\n\tpublic recover(re: RecognitionException): void {\n\t\tif (re instanceof LexerNoViableAltException) {\n\t\t\tif (this._input.LA(1) !== IntStream.EOF) {\n\t\t\t\t// skip a char and try again\n\t\t\t\tthis.interpreter.consume(this._input);\n\t\t\t}\n\t\t} else {\n\t\t\t//System.out.println(\"consuming char \"+(char)input.LA(1)+\" during recovery\");\n\t\t\t//re.printStackTrace();\n\t\t\t// TODO: Do we lose character or line position information?\n\t\t\tthis._input.consume();\n\t\t}\n\t}\n}\n"]}