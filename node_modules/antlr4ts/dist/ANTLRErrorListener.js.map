{"version":3,"file":"ANTLRErrorListener.js","sourceRoot":"","sources":["../../src/ANTLRErrorListener.ts"],"names":[],"mappings":";AAAA;;;GAGG","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:48.7499997-07:00\n\n/** How to emit recognition errors. */\nimport { Recognizer } from \"./Recognizer\";\nimport { RecognitionException } from \"./RecognitionException\";\n\nexport interface ANTLRErrorListener<TSymbol> {\n\t/**\n\t * Upon syntax error, notify any interested parties. This is not how to\n\t * recover from errors or compute error messages. {@link ANTLRErrorStrategy}\n\t * specifies how to recover from syntax errors and how to compute error\n\t * messages. This listener's job is simply to emit a computed message,\n\t * though it has enough information to create its own message in many cases.\n\t *\n\t * The {@link RecognitionException} is non-`undefined` for all syntax errors except\n\t * when we discover mismatched token errors that we can recover from\n\t * in-line, without returning from the surrounding rule (via the single\n\t * token insertion and deletion mechanism).\n\t *\n\t * @param recognizer\n\t *        What parser got the error. From this\n\t * \t\t  object, you can access the context as well\n\t * \t\t  as the input stream.\n\t * @param offendingSymbol\n\t *        The offending token in the input token\n\t * \t\t  stream, unless recognizer is a lexer (then it's `undefined`). If\n\t * \t\t  no viable alternative error, `e` has token at which we\n\t * \t\t  started production for the decision.\n\t * @param line\n\t * \t\t  The line number in the input where the error occurred.\n\t * @param charPositionInLine\n\t * \t\t  The character position within that line where the error occurred.\n\t * @param msg\n\t * \t\t  The message to emit.\n\t * @param e\n\t *        The exception generated by the parser that led to\n\t *        the reporting of an error. It is `undefined` in the case where\n\t *        the parser was able to recover in line without exiting the\n\t *        surrounding rule.\n\t */\n\tsyntaxError?: <T extends TSymbol>(\n\t\t/*@NotNull*/\n\t\trecognizer: Recognizer<T, any>,\n\t\toffendingSymbol: T | undefined,\n\t\tline: number,\n\t\tcharPositionInLine: number,\n\t\t/*@NotNull*/\n\t\tmsg: string,\n\t\te: RecognitionException | undefined) => void;\n}\n"]}