{"version":3,"file":"VocabularyImpl.js","sourceRoot":"","sources":["../../src/VocabularyImpl.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;AAEH,wDAAwD;AAExD,6CAAiD;AACjD,mCAAgC;AAGhC;;;;;GAKG;AACH;IAoBC;;;;;;;;;;;;;;;;OAgBG;IACH,YAAY,YAAuC,EAAE,aAAwC,EAAE,YAAuC;QACrI,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;QACnC,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,sEAAsE;QACtE,IAAI,CAAC,aAAa;YACjB,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,EAChC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;IACtE,CAAC;IAGD,IAAI,YAAY;QACf,OAAO,IAAI,CAAC,aAAa,CAAC;IAC3B,CAAC;IAGM,cAAc,CAAC,SAAiB;QACtC,IAAI,SAAS,IAAI,CAAC,IAAI,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE;YAC3D,OAAO,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;SACpC;QAED,OAAO,SAAS,CAAC;IAClB,CAAC;IAGM,eAAe,CAAC,SAAiB;QACvC,IAAI,SAAS,IAAI,CAAC,IAAI,SAAS,GAAG,IAAI,CAAC,aAAa,CAAC,MAAM,EAAE;YAC5D,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;SACrC;QAED,IAAI,SAAS,KAAK,aAAK,CAAC,GAAG,EAAE;YAC5B,OAAO,KAAK,CAAC;SACb;QAED,OAAO,SAAS,CAAC;IAClB,CAAC;IAIM,cAAc,CAAC,SAAiB;QACtC,IAAI,SAAS,IAAI,CAAC,IAAI,SAAS,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM,EAAE;YAC3D,IAAI,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;YAC/C,IAAI,WAAW,EAAE;gBAChB,OAAO,WAAW,CAAC;aACnB;SACD;QAED,IAAI,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;QACjD,IAAI,WAAW,EAAE;YAChB,OAAO,WAAW,CAAC;SACnB;QAED,IAAI,YAAY,GAAG,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;QACnD,IAAI,YAAY,EAAE;YACjB,OAAO,YAAY,CAAC;SACpB;QAED,OAAO,MAAM,CAAC,SAAS,CAAC,CAAC;IAC1B,CAAC;;AA9FD;;;;;;GAMG;AAEoB,+BAAgB,GAAmB,IAAI,cAAc,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;AAGzF;IADC,oBAAO;oDACiD;AAEzD;IADC,oBAAO;qDACkD;AAE1D;IADC,oBAAO;oDACiD;AAgCzD;IADC,qBAAQ;kDAGR;AAGD;IADC,qBAAQ;oDAOR;AAGD;IADC,qBAAQ;qDAWR;AAID;IAFC,qBAAQ;IACR,oBAAO;oDAoBP;AAtFD;IADC,oBAAO;8CACiF;AAT1F,wCAgGC","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:59.5829654-07:00\n\nimport { NotNull, Override } from \"./Decorators\";\nimport { Token } from \"./Token\";\nimport { Vocabulary } from \"./Vocabulary\";\n\n/**\n * This class provides a default implementation of the {@link Vocabulary}\n * interface.\n *\n * @author Sam Harwell\n */\nexport class VocabularyImpl implements Vocabulary {\n\t/**\n\t * Gets an empty {@link Vocabulary} instance.\n\t *\n\t * No literal or symbol names are assigned to token types, so\n\t * {@link #getDisplayName(int)} returns the numeric value for all tokens\n\t * except {@link Token#EOF}.\n\t */\n\t@NotNull\n\tpublic static readonly EMPTY_VOCABULARY: VocabularyImpl = new VocabularyImpl([], [], []);\n\n\t@NotNull\n\tprivate readonly literalNames: Array<string | undefined>;\n\t@NotNull\n\tprivate readonly symbolicNames: Array<string | undefined>;\n\t@NotNull\n\tprivate readonly displayNames: Array<string | undefined>;\n\n\tprivate _maxTokenType: number;\n\n\t/**\n\t * Constructs a new instance of {@link VocabularyImpl} from the specified\n\t * literal, symbolic, and display token names.\n\t *\n\t * @param literalNames The literal names assigned to tokens, or an empty array\n\t * if no literal names are assigned.\n\t * @param symbolicNames The symbolic names assigned to tokens, or\n\t * an empty array if no symbolic names are assigned.\n\t * @param displayNames The display names assigned to tokens, or an empty array\n\t * to use the values in `literalNames` and `symbolicNames` as\n\t * the source of display names, as described in\n\t * {@link #getDisplayName(int)}.\n\t *\n\t * @see #getLiteralName(int)\n\t * @see #getSymbolicName(int)\n\t * @see #getDisplayName(int)\n\t */\n\tconstructor(literalNames: Array<string | undefined>, symbolicNames: Array<string | undefined>, displayNames: Array<string | undefined>) {\n\t\tthis.literalNames = literalNames;\n\t\tthis.symbolicNames = symbolicNames;\n\t\tthis.displayNames = displayNames;\n\t\t// See note here on -1 part: https://github.com/antlr/antlr4/pull/1146\n\t\tthis._maxTokenType =\n\t\t\tMath.max(this.displayNames.length,\n\t\t\t\tMath.max(this.literalNames.length, this.symbolicNames.length)) - 1;\n\t}\n\n\t@Override\n\tget maxTokenType(): number {\n\t\treturn this._maxTokenType;\n\t}\n\n\t@Override\n\tpublic getLiteralName(tokenType: number): string | undefined {\n\t\tif (tokenType >= 0 && tokenType < this.literalNames.length) {\n\t\t\treturn this.literalNames[tokenType];\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t@Override\n\tpublic getSymbolicName(tokenType: number): string | undefined {\n\t\tif (tokenType >= 0 && tokenType < this.symbolicNames.length) {\n\t\t\treturn this.symbolicNames[tokenType];\n\t\t}\n\n\t\tif (tokenType === Token.EOF) {\n\t\t\treturn \"EOF\";\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t@Override\n\t@NotNull\n\tpublic getDisplayName(tokenType: number): string {\n\t\tif (tokenType >= 0 && tokenType < this.displayNames.length) {\n\t\t\tlet displayName = this.displayNames[tokenType];\n\t\t\tif (displayName) {\n\t\t\t\treturn displayName;\n\t\t\t}\n\t\t}\n\n\t\tlet literalName = this.getLiteralName(tokenType);\n\t\tif (literalName) {\n\t\t\treturn literalName;\n\t\t}\n\n\t\tlet symbolicName = this.getSymbolicName(tokenType);\n\t\tif (symbolicName) {\n\t\t\treturn symbolicName;\n\t\t}\n\n\t\treturn String(tokenType);\n\t}\n}\n"]}