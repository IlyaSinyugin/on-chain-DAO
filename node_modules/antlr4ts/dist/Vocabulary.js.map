{"version":3,"file":"Vocabulary.js","sourceRoot":"","sources":["../../src/Vocabulary.ts"],"names":[],"mappings":";AAAA;;;GAGG","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:59.4986610-07:00\n\n/**\n * This interface provides information about the vocabulary used by a\n * recognizer.\n *\n * @see Recognizer.vocabulary\n * @author Sam Harwell\n */\nexport interface Vocabulary {\n\n\t/**\n\t * Returns the highest token type value. It can be used to iterate from\n\t * zero to that number, inclusively, thus querying all stored entries.\n\t * @returns the highest token type value\n\t */\n\treadonly maxTokenType: number;\n\n\t/**\n\t * Gets the string literal associated with a token type. The string returned\n\t * by this method, when not `undefined`, can be used unaltered in a parser\n\t * grammar to represent this token type.\n\t *\n\t * The following table shows examples of lexer rules and the literal\n\t * names assigned to the corresponding token types.\n\t *\n\t * <table>\n\t *  <tr>\n\t *   <th>Rule</th>\n\t *   <th>Literal Name</th>\n\t *   <th>Java String Literal</th>\n\t *  </tr>\n\t *  <tr>\n\t *   <td>`THIS : 'this';`</td>\n\t *   <td>`'this'`</td>\n\t *   <td>`\"'this'\"`</td>\n\t *  </tr>\n\t *  <tr>\n\t *   <td>`SQUOTE : '\\'';`</td>\n\t *   <td>`'\\''`</td>\n\t *   <td>`\"'\\\\''\"`</td>\n\t *  </tr>\n\t *  <tr>\n\t *   <td>`ID : [A-Z]+;`</td>\n\t *   <td>n/a</td>\n\t *   <td>`undefined`</td>\n\t *  </tr>\n\t * </table>\n\t *\n\t * @param tokenType The token type.\n\t *\n\t * @returns The string literal associated with the specified token type, or\n\t * `undefined` if no string literal is associated with the type.\n\t */\n\tgetLiteralName(tokenType: number): string | undefined;\n\n\t/**\n\t * Gets the symbolic name associated with a token type. The string returned\n\t * by this method, when not `undefined`, can be used unaltered in a parser\n\t * grammar to represent this token type.\n\t *\n\t * This method supports token types defined by any of the following\n\t * methods:\n\t *\n\t * * Tokens created by lexer rules.\n\t * * Tokens defined in a `tokens{}` block in a lexer or parser\n\t *   grammar.\n\t * * The implicitly defined `EOF` token, which has the token type\n\t *   {@link Token#EOF}.\n\t *\n\t * The following table shows examples of lexer rules and the literal\n\t * names assigned to the corresponding token types.\n\t *\n\t * <table>\n\t *  <tr>\n\t *   <th>Rule</th>\n\t *   <th>Symbolic Name</th>\n\t *  </tr>\n\t *  <tr>\n\t *   <td>`THIS : 'this';`</td>\n\t *   <td>`THIS`</td>\n\t *  </tr>\n\t *  <tr>\n\t *   <td>`SQUOTE : '\\'';`</td>\n\t *   <td>`SQUOTE`</td>\n\t *  </tr>\n\t *  <tr>\n\t *   <td>`ID : [A-Z]+;`</td>\n\t *   <td>`ID`</td>\n\t *  </tr>\n\t * </table>\n\t *\n\t * @param tokenType The token type.\n\t *\n\t * @returns The symbolic name associated with the specified token type, or\n\t * `undefined` if no symbolic name is associated with the type.\n\t */\n\tgetSymbolicName(tokenType: number): string | undefined;\n\n\t/**\n\t * Gets the display name of a token type.\n\t *\n\t * ANTLR provides a default implementation of this method, but\n\t * applications are free to override the behavior in any manner which makes\n\t * sense for the application. The default implementation returns the first\n\t * result from the following list which produces a non-`undefined`\n\t * result.\n\t *\n\t * 1. The result of {@link #getLiteralName}\n\t * 1. The result of {@link #getSymbolicName}\n\t * 1. The result of {@link Integer#toString}\n\t *\n\t * @param tokenType The token type.\n\t *\n\t * @returns The display name of the token type, for use in error reporting or\n\t * other user-visible messages which reference specific token types.\n\t */\n\t//@NotNull\n\tgetDisplayName(tokenType: number): string;\n\n}\n"]}