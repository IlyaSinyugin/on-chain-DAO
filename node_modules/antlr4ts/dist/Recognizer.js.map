{"version":3,"file":"Recognizer.js","sourceRoot":"","sources":["../../src/Recognizer.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;;;;AAMH,iEAA8D;AAG9D,6DAA0D;AAG1D,6CAAyD;AACzD,mCAAgC;AAIhC,sCAAsC;AAEtC;IAAA;QAUkB,eAAU,GAAuC,CAAC,2CAAoB,CAAC,QAAQ,CAAC,CAAC;QAI1F,iBAAY,GAAG,CAAC,CAAC,CAAC;IAkN3B,CAAC;IAtMA;;;;OAIG;IAEI,eAAe;QACrB,IAAI,UAAU,GAAe,IAAI,CAAC,UAAU,CAAC;QAC7C,IAAI,MAAM,GAAG,UAAU,CAAC,iBAAiB,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QAC1D,IAAI,MAAM,IAAI,IAAI,EAAE;YACnB,IAAI,kBAAkB,GAAG,IAAI,GAAG,EAAkB,CAAC;YACnD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,YAAY,EAAE,CAAC,EAAE,EAAE;gBAChD,IAAI,WAAW,GAAG,UAAU,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;gBAC/C,IAAI,WAAW,IAAI,IAAI,EAAE;oBACxB,kBAAkB,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC;iBACvC;gBAED,IAAI,YAAY,GAAG,UAAU,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC;gBACjD,IAAI,YAAY,IAAI,IAAI,EAAE;oBACzB,kBAAkB,CAAC,GAAG,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC;iBACxC;aACD;YAED,kBAAkB,CAAC,GAAG,CAAC,KAAK,EAAE,aAAK,CAAC,GAAG,CAAC,CAAC;YACzC,MAAM,GAAG,kBAAkB,CAAC;YAC5B,UAAU,CAAC,iBAAiB,CAAC,GAAG,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;SACrD;QAED,OAAO,MAAM,CAAC;IACf,CAAC;IAED;;;;OAIG;IAEI,eAAe;QACrB,IAAI,SAAS,GAAa,IAAI,CAAC,SAAS,CAAC;QACzC,IAAI,SAAS,IAAI,IAAI,EAAE;YACtB,MAAM,IAAI,KAAK,CAAC,+DAA+D,CAAC,CAAC;SACjF;QAED,IAAI,MAAM,GAA4C,UAAU,CAAC,iBAAiB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QAClG,IAAI,MAAM,IAAI,IAAI,EAAE;YACnB,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;YAChC,UAAU,CAAC,iBAAiB,CAAC,GAAG,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;SACpD;QAED,OAAO,MAAM,CAAC;IACf,CAAC;IAEM,YAAY,CAAC,SAAiB;QACpC,IAAI,KAAK,GAAG,IAAI,CAAC,eAAe,EAAE,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;QAClD,IAAI,KAAK,IAAI,IAAI,EAAE;YAClB,OAAO,KAAK,CAAC;SACb;QACD,OAAO,aAAK,CAAC,YAAY,CAAC;IAC3B,CAAC;IAED;;;;;;OAMG;IAEH,IAAI,aAAa;QAChB,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;IAC/C,CAAC;IAOD;;;;OAIG;IAEH,IAAI,GAAG;QACN,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC;IACzB,CAAC;IAED;;;;OAIG;IAEH,IAAI,WAAW;QACd,OAAO,IAAI,CAAC,OAAO,CAAC;IACrB,CAAC;IAED;;;;;OAKG;IACH,IAAI,WAAW,CAAU,WAA2B;QACnD,IAAI,CAAC,OAAO,GAAG,WAAW,CAAC;IAC5B,CAAC;IAED;;;;OAIG;IACH,IAAI,SAAS;QACZ,OAAO,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IACnC,CAAC;IAED,8EAA8E;IAEvE,cAAc,CAAU,CAAuB;QACrD,IAAI,KAAK,GAAG,CAAC,CAAC,iBAAiB,EAAE,CAAC;QAClC,IAAI,CAAC,KAAK,EAAE;YACX,OAAO,EAAE,CAAC;SACV;QACD,IAAI,IAAI,GAAG,KAAK,CAAC,IAAI,CAAC;QACtB,IAAI,kBAAkB,GAAW,KAAK,CAAC,kBAAkB,CAAC;QAC1D,OAAO,OAAO,GAAG,IAAI,GAAG,GAAG,GAAG,kBAAkB,CAAC;IAClD,CAAC;IAED;;OAEG;IACI,gBAAgB,CAAU,QAAqC;QACrE,IAAI,CAAC,QAAQ,EAAE;YACd,MAAM,IAAI,SAAS,CAAC,2BAA2B,CAAC,CAAC;SACjD;QACD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAChC,CAAC;IAEM,mBAAmB,CAAU,QAAqC;QACxE,IAAI,QAAQ,GAAG,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;QACjD,IAAI,QAAQ,KAAK,CAAC,CAAC,EAAE;YACpB,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC,CAAC,CAAC;SACpC;IACF,CAAC;IAEM,oBAAoB;QAC1B,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC;IAC5B,CAAC;IAGM,iBAAiB;QACvB,OAAO,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACjC,CAAC;IAEM,wBAAwB;QAC9B,OAAO,IAAI,uCAAkB,CAAuC,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC;IAC/F,CAAC;IAED,oEAAoE;IACpE,uCAAuC;IAChC,OAAO,CACb,SAAkC,EAClC,SAAiB,EACjB,WAAmB;QACnB,OAAO,IAAI,CAAC;IACb,CAAC;IAEM,QAAQ,CACd,QAAiC,EACjC,UAAkB;QAClB,OAAO,IAAI,CAAC;IACb,CAAC;IAEM,MAAM,CACZ,SAAkC,EAClC,SAAiB,EACjB,WAAmB;QACnB,sBAAsB;IACvB,CAAC;IAED,IAAI,KAAK;QACR,OAAO,IAAI,CAAC,YAAY,CAAC;IAC1B,CAAC;IAED;;;;;;OAMG;IACH,IAAI,KAAK,CAAC,QAAgB;QAC3B,6CAA6C;QAC3C,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC;QAC/B,+CAA+C;IAC9C,CAAC;;AA5NsB,cAAG,GAAW,CAAC,CAAC,CAAC;AAEzB,4BAAiB,GAC/B,IAAI,OAAO,EAA2C,CAAC;AACzC,4BAAiB,GAC/B,IAAI,OAAO,EAAyC,CAAC;AAItD;IAFC,6BAAgB,CAAC,QAAQ,CAAC;IAC1B,oBAAO;8CAC0F;AAsBlG;IADC,oBAAO;iDAwBP;AAQD;IADC,oBAAO;iDAcP;AAkBD;IADC,oBAAO;+CAGP;AAaD;IADC,oBAAO;qCAGP;AAQD;IADC,oBAAO;IAWS,WAAA,oBAAO,CAAA;6CARvB;AAuBD;IADC,oBAAO;IACe,WAAA,oBAAO,CAAA;gDAQ7B;AAKD;IAAyB,WAAA,oBAAO,CAAA;kDAK/B;AAED;IAA4B,WAAA,oBAAO,CAAA;qDAKlC;AAOD;IADC,oBAAO;mDAGP;AAlLF,gCAgOC","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:57.1954441-07:00\nimport { ANTLRErrorListener } from \"./ANTLRErrorListener\";\nimport { ATN } from \"./atn/ATN\";\nimport { ATNSimulator } from \"./atn/ATNSimulator\";\nimport { ConsoleErrorListener } from \"./ConsoleErrorListener\";\nimport { IntStream } from \"./IntStream\";\nimport { ParseInfo } from \"./atn/ParseInfo\";\nimport { ProxyErrorListener } from \"./ProxyErrorListener\";\nimport { RecognitionException } from \"./RecognitionException\";\nimport { RuleContext } from \"./RuleContext\";\nimport { SuppressWarnings, NotNull } from \"./Decorators\";\nimport { Token } from \"./Token\";\nimport { Vocabulary } from \"./Vocabulary\";\nimport { VocabularyImpl } from \"./VocabularyImpl\";\n\nimport * as Utils from \"./misc/Utils\";\n\nexport abstract class Recognizer<TSymbol, ATNInterpreter extends ATNSimulator> {\n\tpublic static readonly EOF: number = -1;\n\n\tprivate static tokenTypeMapCache =\n\t\tnew WeakMap<Vocabulary, ReadonlyMap<string, number>>();\n\tprivate static ruleIndexMapCache =\n\t\tnew WeakMap<string[], ReadonlyMap<string, number>>();\n\n\t@SuppressWarnings(\"serial\")\n\t@NotNull\n\tprivate readonly _listeners: Array<ANTLRErrorListener<TSymbol>> = [ConsoleErrorListener.INSTANCE];\n\n\tprotected _interp: ATNInterpreter;\n\n\tprivate _stateNumber = -1;\n\n\tpublic abstract readonly ruleNames: string[];\n\n\t/**\n\t * Get the vocabulary used by the recognizer.\n\t *\n\t * @returns A {@link Vocabulary} instance providing information about the\n\t * vocabulary used by the grammar.\n\t */\n\tpublic abstract readonly vocabulary: Vocabulary;\n\n\t/**\n\t * Get a map from token names to token types.\n\t *\n\t * Used for XPath and tree pattern compilation.\n\t */\n\t@NotNull\n\tpublic getTokenTypeMap(): ReadonlyMap<string, number> {\n\t\tlet vocabulary: Vocabulary = this.vocabulary;\n\t\tlet result = Recognizer.tokenTypeMapCache.get(vocabulary);\n\t\tif (result == null) {\n\t\t\tlet intermediateResult = new Map<string, number>();\n\t\t\tfor (let i = 0; i <= this.atn.maxTokenType; i++) {\n\t\t\t\tlet literalName = vocabulary.getLiteralName(i);\n\t\t\t\tif (literalName != null) {\n\t\t\t\t\tintermediateResult.set(literalName, i);\n\t\t\t\t}\n\n\t\t\t\tlet symbolicName = vocabulary.getSymbolicName(i);\n\t\t\t\tif (symbolicName != null) {\n\t\t\t\t\tintermediateResult.set(symbolicName, i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tintermediateResult.set(\"EOF\", Token.EOF);\n\t\t\tresult = intermediateResult;\n\t\t\tRecognizer.tokenTypeMapCache.set(vocabulary, result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Get a map from rule names to rule indexes.\n\t *\n\t * Used for XPath and tree pattern compilation.\n\t */\n\t@NotNull\n\tpublic getRuleIndexMap(): ReadonlyMap<string, number> {\n\t\tlet ruleNames: string[] = this.ruleNames;\n\t\tif (ruleNames == null) {\n\t\t\tthrow new Error(\"The current recognizer does not provide a list of rule names.\");\n\t\t}\n\n\t\tlet result: ReadonlyMap<string, number> | undefined = Recognizer.ruleIndexMapCache.get(ruleNames);\n\t\tif (result == null) {\n\t\t\tresult = Utils.toMap(ruleNames);\n\t\t\tRecognizer.ruleIndexMapCache.set(ruleNames, result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic getTokenType(tokenName: string): number {\n\t\tlet ttype = this.getTokenTypeMap().get(tokenName);\n\t\tif (ttype != null) {\n\t\t\treturn ttype;\n\t\t}\n\t\treturn Token.INVALID_TYPE;\n\t}\n\n\t/**\n\t * If this recognizer was generated, it will have a serialized ATN\n\t * representation of the grammar.\n\t *\n\t * For interpreters, we don't know their serialized ATN despite having\n\t * created the interpreter from it.\n\t */\n\t@NotNull\n\tget serializedATN(): string {\n\t\tthrow new Error(\"there is no serialized ATN\");\n\t}\n\n\t/** For debugging and other purposes, might want the grammar name.\n\t *  Have ANTLR generate an implementation for this method.\n\t */\n\tpublic abstract readonly grammarFileName: string;\n\n\t/**\n\t * Get the {@link ATN} used by the recognizer for prediction.\n\t *\n\t * @returns The {@link ATN} used by the recognizer for prediction.\n\t */\n\t@NotNull\n\tget atn(): ATN {\n\t\treturn this._interp.atn;\n\t}\n\n\t/**\n\t * Get the ATN interpreter used by the recognizer for prediction.\n\t *\n\t * @returns The ATN interpreter used by the recognizer for prediction.\n\t */\n\t@NotNull\n\tget interpreter(): ATNInterpreter {\n\t\treturn this._interp;\n\t}\n\n\t/**\n\t * Set the ATN interpreter used by the recognizer for prediction.\n\t *\n\t * @param interpreter The ATN interpreter used by the recognizer for\n\t * prediction.\n\t */\n\tset interpreter(@NotNull interpreter: ATNInterpreter) {\n\t\tthis._interp = interpreter;\n\t}\n\n\t/** If profiling during the parse/lex, this will return DecisionInfo records\n\t *  for each decision in recognizer in a ParseInfo object.\n\t *\n\t * @since 4.3\n\t */\n\tget parseInfo(): Promise<ParseInfo | undefined> {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\t/** What is the error header, normally line/character position information? */\n\t@NotNull\n\tpublic getErrorHeader(@NotNull e: RecognitionException): string {\n\t\tlet token = e.getOffendingToken();\n\t\tif (!token) {\n\t\t\treturn \"\";\n\t\t}\n\t\tlet line = token.line;\n\t\tlet charPositionInLine: number = token.charPositionInLine;\n\t\treturn \"line \" + line + \":\" + charPositionInLine;\n\t}\n\n\t/**\n\t * @exception NullPointerException if `listener` is `undefined`.\n\t */\n\tpublic addErrorListener(@NotNull listener: ANTLRErrorListener<TSymbol>): void {\n\t\tif (!listener) {\n\t\t\tthrow new TypeError(\"listener must not be null\");\n\t\t}\n\t\tthis._listeners.push(listener);\n\t}\n\n\tpublic removeErrorListener(@NotNull listener: ANTLRErrorListener<TSymbol>): void {\n\t\tlet position = this._listeners.indexOf(listener);\n\t\tif (position !== -1) {\n\t\t\tthis._listeners.splice(position, 1);\n\t\t}\n\t}\n\n\tpublic removeErrorListeners(): void {\n\t\tthis._listeners.length = 0;\n\t}\n\n\t@NotNull\n\tpublic getErrorListeners(): Array<ANTLRErrorListener<TSymbol>> {\n\t\treturn this._listeners.slice(0);\n\t}\n\n\tpublic getErrorListenerDispatch(): ANTLRErrorListener<TSymbol> {\n\t\treturn new ProxyErrorListener<TSymbol, ANTLRErrorListener<TSymbol>>(this.getErrorListeners());\n\t}\n\n\t// subclass needs to override these if there are sempreds or actions\n\t// that the ATN interp needs to execute\n\tpublic sempred(\n\t\t_localctx: RuleContext | undefined,\n\t\truleIndex: number,\n\t\tactionIndex: number): boolean {\n\t\treturn true;\n\t}\n\n\tpublic precpred(\n\t\tlocalctx: RuleContext | undefined,\n\t\tprecedence: number): boolean {\n\t\treturn true;\n\t}\n\n\tpublic action(\n\t\t_localctx: RuleContext | undefined,\n\t\truleIndex: number,\n\t\tactionIndex: number): void {\n\t\t// intentionally empty\n\t}\n\n\tget state(): number {\n\t\treturn this._stateNumber;\n\t}\n\n\t/** Indicate that the recognizer has changed internal state that is\n\t *  consistent with the ATN state passed in.  This way we always know\n\t *  where we are in the ATN as the parser goes along. The rule\n\t *  context objects form a stack that lets us see the stack of\n\t *  invoking rules. Combine this and we have complete ATN\n\t *  configuration information.\n\t */\n\tset state(atnState: number) {\n//\t\tSystem.err.println(\"setState \"+atnState);\n\t\tthis._stateNumber = atnState;\n//\t\tif ( traceATNStates ) _ctx.trace(atnState);\n\t}\n\n\tpublic abstract readonly inputStream: IntStream | undefined;\n}\n"]}