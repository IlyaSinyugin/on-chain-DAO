{"version":3,"file":"ParserInterpreter.js","sourceRoot":"","sources":["../../src/ParserInterpreter.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:53.1043451-07:00\n\nimport { ActionTransition } from \"./atn/ActionTransition\";\nimport { ATN } from \"./atn/ATN\";\nimport { ATNState } from \"./atn/ATNState\";\nimport { ATNStateType } from \"./atn/ATNStateType\";\nimport { AtomTransition } from \"./atn/AtomTransition\";\nimport { BitSet } from \"./misc/BitSet\";\nimport { DecisionState } from \"./atn/DecisionState\";\nimport { FailedPredicateException } from \"./FailedPredicateException\";\nimport { InputMismatchException } from \"./InputMismatchException\";\nimport { InterpreterRuleContext } from \"./InterpreterRuleContext\";\nimport { LoopEndState } from \"./atn/LoopEndState\";\nimport { NotNull } from \"./Decorators\";\nimport { Override } from \"./Decorators\";\nimport { Parser } from \"./Parser\";\nimport { ParserATNSimulator } from \"./atn/ParserATNSimulator\";\nimport { ParserRuleContext } from \"./ParserRuleContext\";\nimport { PrecedencePredicateTransition } from \"./atn/PrecedencePredicateTransition\";\nimport { PredicateTransition } from \"./atn/PredicateTransition\";\nimport { RecognitionException } from \"./RecognitionException\";\nimport { RuleStartState } from \"./atn/RuleStartState\";\nimport { RuleTransition } from \"./atn/RuleTransition\";\nimport { StarLoopEntryState } from \"./atn/StarLoopEntryState\";\nimport { Token } from \"./Token\";\nimport { TokenStream } from \"./TokenStream\";\nimport { Transition } from \"./atn/Transition\";\nimport { TransitionType } from \"./atn/TransitionType\";\nimport { Vocabulary } from \"./Vocabulary\";\n\n/** A parser simulator that mimics what ANTLR's generated\n *  parser code does. A ParserATNSimulator is used to make\n *  predictions via adaptivePredict but this class moves a pointer through the\n *  ATN to simulate parsing. ParserATNSimulator just\n *  makes us efficient rather than having to backtrack, for example.\n *\n *  This properly creates parse trees even for left recursive rules.\n *\n *  We rely on the left recursive rule invocation and special predicate\n *  transitions to make left recursive rules work.\n *\n *  See TestParserInterpreter for examples.\n */\nexport class ParserInterpreter extends Parser {\n\tprotected _grammarFileName: string;\n\tprotected _atn: ATN;\n\t/** This identifies StarLoopEntryState's that begin the (...)*\n\t *  precedence loops of left recursive rules.\n\t */\n\tprotected pushRecursionContextStates: BitSet;\n\n\tprotected _ruleNames: string[];\n\t@NotNull\n\tprivate _vocabulary: Vocabulary;\n\n\t/** This stack corresponds to the _parentctx, _parentState pair of locals\n\t *  that would exist on call stack frames with a recursive descent parser;\n\t *  in the generated function for a left-recursive rule you'd see:\n\t *\n\t *  private EContext e(int _p) {\n\t *      ParserRuleContext _parentctx = _ctx;    // Pair.a\n\t *      int _parentState = state;          // Pair.b\n\t *      ...\n\t *  }\n\t *\n\t *  Those values are used to create new recursive rule invocation contexts\n\t *  associated with left operand of an alt like \"expr '*' expr\".\n\t */\n\tprotected readonly _parentContextStack: Array<[ParserRuleContext, number]> = [];\n\n\t/** We need a map from (decision,inputIndex)->forced alt for computing ambiguous\n\t *  parse trees. For now, we allow exactly one override.\n\t */\n\tprotected overrideDecision: number = -1;\n\tprotected overrideDecisionInputIndex: number = -1;\n\tprotected overrideDecisionAlt: number = -1;\n\tprotected overrideDecisionReached: boolean = false; // latch and only override once; error might trigger infinite loop\n\n\t/** What is the current context when we override a decisions?  This tells\n\t *  us what the root of the parse tree is when using override\n\t *  for an ambiguity/lookahead check.\n\t */\n\tprotected _overrideDecisionRoot?: InterpreterRuleContext = undefined;\n\n\tprotected _rootContext: InterpreterRuleContext;\n\n\t/** A copy constructor that creates a new parser interpreter by reusing\n\t *  the fields of a previous interpreter.\n\t *\n\t *  @param old The interpreter to copy\n\t *\n\t *  @since 4.5\n\t */\n\tconstructor(/*@NotNull*/ old: ParserInterpreter);\n\tconstructor(\n\t\tgrammarFileName: string, /*@NotNull*/ vocabulary: Vocabulary,\n\t\truleNames: string[], atn: ATN, input: TokenStream);\n\tconstructor(\n\t\tgrammarFileName: ParserInterpreter | string, @NotNull vocabulary?: Vocabulary,\n\t\truleNames?: string[], atn?: ATN, input?: TokenStream) {\n\t\tsuper(grammarFileName instanceof ParserInterpreter ? grammarFileName.inputStream : input!);\n\t\tif (grammarFileName instanceof ParserInterpreter) {\n\t\t\tlet old: ParserInterpreter = grammarFileName;\n\t\t\tthis._grammarFileName = old._grammarFileName;\n\t\t\tthis._atn = old._atn;\n\t\t\tthis.pushRecursionContextStates = old.pushRecursionContextStates;\n\t\t\tthis._ruleNames = old._ruleNames;\n\t\t\tthis._vocabulary = old._vocabulary;\n\t\t\tthis.interpreter = new ParserATNSimulator(this._atn, this);\n\t\t} else {\n\t\t\t// The second constructor requires non-null arguments\n\t\t\tvocabulary = vocabulary!;\n\t\t\truleNames = ruleNames!;\n\t\t\tatn = atn!;\n\n\t\t\tthis._grammarFileName = grammarFileName;\n\t\t\tthis._atn = atn;\n\t\t\tthis._ruleNames = ruleNames.slice(0);\n\t\t\tthis._vocabulary = vocabulary;\n\n\t\t\t// identify the ATN states where pushNewRecursionContext() must be called\n\t\t\tthis.pushRecursionContextStates = new BitSet(atn.states.length);\n\t\t\tfor (let state of atn.states) {\n\t\t\t\tif (!(state instanceof StarLoopEntryState)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (state.precedenceRuleDecision) {\n\t\t\t\t\tthis.pushRecursionContextStates.set(state.stateNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get atn simulator that knows how to do predictions\n\t\t\tthis.interpreter = new ParserATNSimulator(atn, this);\n\t\t}\n\t}\n\n\t@Override\n\tpublic reset(resetInput?: boolean): void {\n\t\tif (resetInput === undefined) {\n\t\t\tsuper.reset();\n\t\t} else {\n\t\t\tsuper.reset(resetInput);\n\t\t}\n\n\t\tthis.overrideDecisionReached = false;\n\t\tthis._overrideDecisionRoot = undefined;\n\t}\n\n\t@Override\n\tget atn(): ATN {\n\t\treturn this._atn;\n\t}\n\n\t@Override\n\tget vocabulary(): Vocabulary {\n\t\treturn this._vocabulary;\n\t}\n\n\t@Override\n\tget ruleNames(): string[] {\n\t\treturn this._ruleNames;\n\t}\n\n\t@Override\n\tget grammarFileName(): string {\n\t\treturn this._grammarFileName;\n\t}\n\n\t/** Begin parsing at startRuleIndex */\n\tpublic parse(startRuleIndex: number): ParserRuleContext {\n\t\tlet startRuleStartState: RuleStartState = this._atn.ruleToStartState[startRuleIndex];\n\n\t\tthis._rootContext = this.createInterpreterRuleContext(undefined, ATNState.INVALID_STATE_NUMBER, startRuleIndex);\n\t\tif (startRuleStartState.isPrecedenceRule) {\n\t\t\tthis.enterRecursionRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);\n\t\t}\n\t\telse {\n\t\t\tthis.enterRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex);\n\t\t}\n\n\t\twhile (true) {\n\t\t\tlet p: ATNState = this.atnState;\n\t\t\tswitch (p.stateType) {\n\t\t\tcase ATNStateType.RULE_STOP:\n\t\t\t\t// pop; return from rule\n\t\t\t\tif (this._ctx.isEmpty) {\n\t\t\t\t\tif (startRuleStartState.isPrecedenceRule) {\n\t\t\t\t\t\tlet result: ParserRuleContext = this._ctx;\n\t\t\t\t\t\tlet parentContext: [ParserRuleContext, number] = this._parentContextStack.pop() !;\n\t\t\t\t\t\tthis.unrollRecursionContexts(parentContext[0]);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.exitRule();\n\t\t\t\t\t\treturn this._rootContext;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.visitRuleStopState(p);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\ttry {\n\t\t\t\t\tthis.visitState(p);\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tif (e instanceof RecognitionException) {\n\t\t\t\t\t\tthis.state = this._atn.ruleToStopState[p.ruleIndex].stateNumber;\n\t\t\t\t\t\tthis.context.exception = e;\n\t\t\t\t\t\tthis.errorHandler.reportError(this, e);\n\t\t\t\t\t\tthis.recover(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic enterRecursionRule(localctx: ParserRuleContext, state: number, ruleIndex: number, precedence: number): void {\n\t\tthis._parentContextStack.push([this._ctx, localctx.invokingState]);\n\t\tsuper.enterRecursionRule(localctx, state, ruleIndex, precedence);\n\t}\n\n\tprotected get atnState(): ATNState {\n\t\treturn this._atn.states[this.state];\n\t}\n\n\tprotected visitState(p: ATNState): void {\n\t\tlet predictedAlt: number = 1;\n\t\tif (p.numberOfTransitions > 1) {\n\t\t\tpredictedAlt = this.visitDecisionState(p as DecisionState);\n\t\t}\n\n\t\tlet transition: Transition = p.transition(predictedAlt - 1);\n\t\tswitch (transition.serializationType) {\n\t\tcase TransitionType.EPSILON:\n\t\t\tif (this.pushRecursionContextStates.get(p.stateNumber) &&\n\t\t\t\t!(transition.target instanceof LoopEndState)) {\n\t\t\t\t// We are at the start of a left recursive rule's (...)* loop\n\t\t\t\t// and we're not taking the exit branch of loop.\n\t\t\t\tlet parentContext = this._parentContextStack[this._parentContextStack.length - 1];\n\t\t\t\tlet localctx: InterpreterRuleContext =\n\t\t\t\t\tthis.createInterpreterRuleContext(parentContext[0], parentContext[1], this._ctx.ruleIndex);\n\t\t\t\tthis.pushNewRecursionContext(localctx,\n\t\t\t\t\tthis._atn.ruleToStartState[p.ruleIndex].stateNumber,\n\t\t\t\t\tthis._ctx.ruleIndex);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TransitionType.ATOM:\n\t\t\tthis.match((transition as AtomTransition)._label);\n\t\t\tbreak;\n\n\t\tcase TransitionType.RANGE:\n\t\tcase TransitionType.SET:\n\t\tcase TransitionType.NOT_SET:\n\t\t\tif (!transition.matches(this._input.LA(1), Token.MIN_USER_TOKEN_TYPE, 65535)) {\n\t\t\t\tthis.recoverInline();\n\t\t\t}\n\t\t\tthis.matchWildcard();\n\t\t\tbreak;\n\n\t\tcase TransitionType.WILDCARD:\n\t\t\tthis.matchWildcard();\n\t\t\tbreak;\n\n\t\tcase TransitionType.RULE:\n\t\t\tlet ruleStartState: RuleStartState = transition.target as RuleStartState;\n\t\t\tlet ruleIndex: number = ruleStartState.ruleIndex;\n\t\t\tlet newctx: InterpreterRuleContext = this.createInterpreterRuleContext(this._ctx, p.stateNumber, ruleIndex);\n\t\t\tif (ruleStartState.isPrecedenceRule) {\n\t\t\t\tthis.enterRecursionRule(newctx, ruleStartState.stateNumber, ruleIndex, (transition as RuleTransition).precedence);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.enterRule(newctx, transition.target.stateNumber, ruleIndex);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TransitionType.PREDICATE:\n\t\t\tlet predicateTransition: PredicateTransition = transition as PredicateTransition;\n\t\t\tif (!this.sempred(this._ctx, predicateTransition.ruleIndex, predicateTransition.predIndex)) {\n\t\t\t\tthrow new FailedPredicateException(this);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase TransitionType.ACTION:\n\t\t\tlet actionTransition: ActionTransition = transition as ActionTransition;\n\t\t\tthis.action(this._ctx, actionTransition.ruleIndex, actionTransition.actionIndex);\n\t\t\tbreak;\n\n\t\tcase TransitionType.PRECEDENCE:\n\t\t\tif (!this.precpred(this._ctx, (transition as PrecedencePredicateTransition).precedence)) {\n\t\t\t\tlet precedence = (transition as PrecedencePredicateTransition).precedence;\n\t\t\t\tthrow new FailedPredicateException(this, `precpred(_ctx, ${precedence})`);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow new Error(\"UnsupportedOperationException: Unrecognized ATN transition type.\");\n\t\t}\n\n\t\tthis.state = transition.target.stateNumber;\n\t}\n\n\t/** Method visitDecisionState() is called when the interpreter reaches\n\t *  a decision state (instance of DecisionState). It gives an opportunity\n\t *  for subclasses to track interesting things.\n\t */\n\tprotected visitDecisionState(p: DecisionState): number {\n\t\tlet predictedAlt: number;\n\t\tthis.errorHandler.sync(this);\n\t\tlet decision: number = p.decision;\n\t\tif (decision === this.overrideDecision && this._input.index === this.overrideDecisionInputIndex && !this.overrideDecisionReached) {\n\t\t\tpredictedAlt = this.overrideDecisionAlt;\n\t\t\tthis.overrideDecisionReached = true;\n\t\t}\n\t\telse {\n\t\t\tpredictedAlt = this.interpreter.adaptivePredict(this._input, decision, this._ctx);\n\t\t}\n\t\treturn predictedAlt;\n\t}\n\n\t/** Provide simple \"factory\" for InterpreterRuleContext's.\n\t *  @since 4.5.1\n\t */\n\tprotected createInterpreterRuleContext(\n\t\tparent: ParserRuleContext | undefined,\n\t\tinvokingStateNumber: number,\n\t\truleIndex: number): InterpreterRuleContext {\n\t\treturn new InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);\n\t}\n\n\tprotected visitRuleStopState(p: ATNState): void {\n\t\tlet ruleStartState: RuleStartState = this._atn.ruleToStartState[p.ruleIndex];\n\t\tif (ruleStartState.isPrecedenceRule) {\n\t\t\tlet parentContext: [ParserRuleContext, number] = this._parentContextStack.pop()!;\n\t\t\tthis.unrollRecursionContexts(parentContext[0]);\n\t\t\tthis.state = parentContext[1];\n\t\t}\n\t\telse {\n\t\t\tthis.exitRule();\n\t\t}\n\n\t\tlet ruleTransition: RuleTransition = this._atn.states[this.state].transition(0) as RuleTransition;\n\t\tthis.state = ruleTransition.followState.stateNumber;\n\t}\n\n\t/** Override this parser interpreters normal decision-making process\n\t *  at a particular decision and input token index. Instead of\n\t *  allowing the adaptive prediction mechanism to choose the\n\t *  first alternative within a block that leads to a successful parse,\n\t *  force it to take the alternative, 1..n for n alternatives.\n\t *\n\t *  As an implementation limitation right now, you can only specify one\n\t *  override. This is sufficient to allow construction of different\n\t *  parse trees for ambiguous input. It means re-parsing the entire input\n\t *  in general because you're never sure where an ambiguous sequence would\n\t *  live in the various parse trees. For example, in one interpretation,\n\t *  an ambiguous input sequence would be matched completely in expression\n\t *  but in another it could match all the way back to the root.\n\t *\n\t *  s : e '!'? ;\n\t *  e : ID\n\t *    | ID '!'\n\t *    ;\n\t *\n\t *  Here, x! can be matched as (s (e ID) !) or (s (e ID !)). In the first\n\t *  case, the ambiguous sequence is fully contained only by the root.\n\t *  In the second case, the ambiguous sequences fully contained within just\n\t *  e, as in: (e ID !).\n\t *\n\t *  Rather than trying to optimize this and make\n\t *  some intelligent decisions for optimization purposes, I settled on\n\t *  just re-parsing the whole input and then using\n\t *  {link Trees#getRootOfSubtreeEnclosingRegion} to find the minimal\n\t *  subtree that contains the ambiguous sequence. I originally tried to\n\t *  record the call stack at the point the parser detected and ambiguity but\n\t *  left recursive rules create a parse tree stack that does not reflect\n\t *  the actual call stack. That impedance mismatch was enough to make\n\t *  it it challenging to restart the parser at a deeply nested rule\n\t *  invocation.\n\t *\n\t *  Only parser interpreters can override decisions so as to avoid inserting\n\t *  override checking code in the critical ALL(*) prediction execution path.\n\t *\n\t *  @since 4.5\n\t */\n\tpublic addDecisionOverride(decision: number, tokenIndex: number, forcedAlt: number): void {\n\t\tthis.overrideDecision = decision;\n\t\tthis.overrideDecisionInputIndex = tokenIndex;\n\t\tthis.overrideDecisionAlt = forcedAlt;\n\t}\n\n\tget overrideDecisionRoot(): InterpreterRuleContext | undefined {\n\t\treturn this._overrideDecisionRoot;\n\t}\n\n\t/** Rely on the error handler for this parser but, if no tokens are consumed\n\t *  to recover, add an error node. Otherwise, nothing is seen in the parse\n\t *  tree.\n\t */\n\tprotected recover(e: RecognitionException): void {\n\t\tlet i: number = this._input.index;\n\t\tthis.errorHandler.recover(this, e);\n\t\tif (this._input.index === i) {\n\t\t\t// no input consumed, better add an error node\n\t\t\tlet tok: Token | undefined = e.getOffendingToken();\n\t\t\tif (!tok) {\n\t\t\t\tthrow new Error(\"Expected exception to have an offending token\");\n\t\t\t}\n\n\t\t\tlet source = tok.tokenSource;\n\t\t\tlet stream = source !== undefined ? source.inputStream : undefined;\n\t\t\tlet sourcePair = { source, stream };\n\n\t\t\tif (e instanceof InputMismatchException) {\n\t\t\t\tlet expectedTokens = e.expectedTokens;\n\t\t\t\tif (expectedTokens === undefined) {\n\t\t\t\t\tthrow new Error(\"Expected the exception to provide expected tokens\");\n\t\t\t\t}\n\n\t\t\t\tlet expectedTokenType: number = Token.INVALID_TYPE;\n\t\t\t\tif (!expectedTokens.isNil) {\n\t\t\t\t\t// get any element\n\t\t\t\t\texpectedTokenType = expectedTokens.minElement;\n\t\t\t\t}\n\n\t\t\t\tlet errToken: Token =\n\t\t\t\t\tthis.tokenFactory.create(sourcePair,\n\t\t\t\t\t\texpectedTokenType, tok.text,\n\t\t\t\t\t\tToken.DEFAULT_CHANNEL,\n\t\t\t\t\t\t-1, -1, // invalid start/stop\n\t\t\t\t\t\ttok.line, tok.charPositionInLine);\n\t\t\t\tthis._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));\n\t\t\t}\n\t\t\telse { // NoViableAlt\n\t\t\t\tlet source = tok.tokenSource;\n\t\t\t\tlet errToken: Token =\n\t\t\t\t\tthis.tokenFactory.create(sourcePair,\n\t\t\t\t\t\tToken.INVALID_TYPE, tok.text,\n\t\t\t\t\t\tToken.DEFAULT_CHANNEL,\n\t\t\t\t\t\t-1, -1, // invalid start/stop\n\t\t\t\t\t\ttok.line, tok.charPositionInLine);\n\t\t\t\tthis._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected recoverInline(): Token {\n\t\treturn this._errHandler.recoverInline(this);\n\t}\n\n\t/** Return the root of the parse, which can be useful if the parser\n\t *  bails out. You still can access the top node. Note that,\n\t *  because of the way left recursive rules add children, it's possible\n\t *  that the root will not have any children if the start rule immediately\n\t *  called and left recursive rule that fails.\n\t *\n\t * @since 4.5.1\n\t */\n\tget rootContext(): InterpreterRuleContext {\n\t\treturn this._rootContext;\n\t}\n}\n"]}