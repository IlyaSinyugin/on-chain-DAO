{"version":3,"file":"TerminalNode.js","sourceRoot":"","sources":["../../../src/tree/TerminalNode.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;AAEH,wDAAwD;AAExD,+CAA4C;AAC5C,8CAAyC;AAMzC,oCAAiC;AAEjC;IAIC,YAAY,MAAa;QACxB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IACvB,CAAC;IAGM,QAAQ,CAAC,CAAS;QACxB,MAAM,IAAI,UAAU,CAAC,gCAAgC,CAAC,CAAC;IACxD,CAAC;IAED,IAAI,MAAM;QACT,OAAO,IAAI,CAAC,OAAO,CAAC;IACrB,CAAC;IAGD,IAAI,MAAM;QACT,OAAO,IAAI,CAAC,OAAO,CAAC;IACrB,CAAC;IAGM,SAAS,CAAC,MAAmB;QACnC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;IACvB,CAAC;IAGD,IAAI,OAAO;QACV,OAAO,IAAI,CAAC,OAAO,CAAC;IACrB,CAAC;IAGD,IAAI,cAAc;QACjB,IAAI,UAAU,GAAW,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC;QACjD,OAAO,IAAI,mBAAQ,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;IAC7C,CAAC;IAGD,IAAI,UAAU;QACb,OAAO,CAAC,CAAC;IACV,CAAC;IAGM,MAAM,CAAI,OAA4B;QAC5C,OAAO,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IACpC,CAAC;IAGD,IAAI,IAAI;QACP,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,IAAI,EAAE,CAAC;IAChC,CAAC;IAGM,YAAY,CAAC,MAAe;QAClC,OAAO,IAAI,CAAC,QAAQ,EAAE,CAAC;IACxB,CAAC;IAGM,QAAQ;QACd,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,KAAK,aAAK,CAAC,GAAG,EAAE;YACpC,OAAO,OAAO,CAAC;SACf;QAED,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,IAAI,EAAE,CAAC;IAChC,CAAC;CACD;AAzDA;IADC,qBAAQ;4CAGR;AAOD;IADC,qBAAQ;0CAGR;AAGD;IADC,qBAAQ;6CAGR;AAGD;IADC,qBAAQ;2CAGR;AAGD;IADC,qBAAQ;kDAIR;AAGD;IADC,qBAAQ;8CAGR;AAGD;IADC,qBAAQ;0CAGR;AAGD;IADC,qBAAQ;wCAGR;AAGD;IADC,qBAAQ;gDAGR;AAGD;IADC,qBAAQ;4CAOR;AAjEF,oCAkEC","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:48.1433686-07:00\n\nimport { Interval } from \"../misc/Interval\";\nimport { Override } from \"../Decorators\";\nimport { Parser } from \"../Parser\";\nimport { ParseTree } from \"./ParseTree\";\nimport { ParseTreeVisitor } from \"./ParseTreeVisitor\";\nimport { RuleContext } from \"../RuleContext\";\nimport { RuleNode } from \"./RuleNode\";\nimport { Token } from \"../Token\";\n\nexport class TerminalNode implements ParseTree {\n\tpublic _symbol: Token;\n\tpublic _parent: RuleNode | undefined;\n\n\tconstructor(symbol: Token) {\n\t\tthis._symbol = symbol;\n\t}\n\n\t@Override\n\tpublic getChild(i: number): never {\n\t\tthrow new RangeError(\"Terminal Node has no children.\");\n\t}\n\n\tget symbol(): Token {\n\t\treturn this._symbol;\n\t}\n\n\t@Override\n\tget parent(): RuleNode | undefined {\n\t\treturn this._parent;\n\t}\n\n\t@Override\n\tpublic setParent(parent: RuleContext): void {\n\t\tthis._parent = parent;\n\t}\n\n\t@Override\n\tget payload(): Token {\n\t\treturn this._symbol;\n\t}\n\n\t@Override\n\tget sourceInterval(): Interval {\n\t\tlet tokenIndex: number = this._symbol.tokenIndex;\n\t\treturn new Interval(tokenIndex, tokenIndex);\n\t}\n\n\t@Override\n\tget childCount(): number {\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic accept<T>(visitor: ParseTreeVisitor<T>): T {\n\t\treturn visitor.visitTerminal(this);\n\t}\n\n\t@Override\n\tget text(): string {\n\t\treturn this._symbol.text || \"\";\n\t}\n\n\t@Override\n\tpublic toStringTree(parser?: Parser): string {\n\t\treturn this.toString();\n\t}\n\n\t@Override\n\tpublic toString(): string {\n\t\tif (this._symbol.type === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t}\n\n\t\treturn this._symbol.text || \"\";\n\t}\n}\n"]}