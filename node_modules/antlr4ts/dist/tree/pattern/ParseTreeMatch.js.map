{"version":3,"file":"ParseTreeMatch.js","sourceRoot":"","sources":["../../../../src/tree/pattern/ParseTreeMatch.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;;;;AAIH,iDAAqD;AAIrD;;GAEG;AACH,IAAa,cAAc,GAA3B;IAqBC;;;;;;;;;;;;;;OAcG;IACH,YACU,IAAe,EACf,OAAyB,EACzB,MAAmC,EAC5C,cAAqC;QACrC,IAAI,CAAC,IAAI,EAAE;YACV,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;SACvC;QAED,IAAI,CAAC,OAAO,EAAE;YACb,MAAM,IAAI,KAAK,CAAC,wBAAwB,CAAC,CAAC;SAC1C;QAED,IAAI,CAAC,MAAM,EAAE;YACZ,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;SACzC;QAED,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;IACvC,CAAC;IAED;;;;;;;;;;;;;;;OAeG;IACI,GAAG,CAAC,KAAa;QACvB,IAAI,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACzC,IAAI,CAAC,UAAU,IAAI,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE;YAC3C,OAAO,SAAS,CAAC;SACjB;QAED,OAAO,UAAU,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,0BAA0B;IACrE,CAAC;IAED;;;;;;;;;;;;;;;;;;;;OAoBG;IAEI,MAAM,CAAU,KAAa;QACnC,MAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QACtC,IAAI,CAAC,KAAK,EAAE;YACX,OAAO,EAAE,CAAC;SACV;QACD,OAAO,KAAK,CAAC;IACd,CAAC;IAED;;;;;;;;;OASG;IAEH,IAAI,MAAM;QACT,OAAO,IAAI,CAAC,OAAO,CAAC;IACrB,CAAC;IAED;;;;;OAKG;IACH,IAAI,cAAc;QACjB,OAAO,IAAI,CAAC,eAAe,CAAC;IAC7B,CAAC;IAED;;;;;OAKG;IACH,IAAI,SAAS;QACZ,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC;IAC9B,CAAC;IAED;;;;OAIG;IAEH,IAAI,OAAO;QACV,OAAO,IAAI,CAAC,QAAQ,CAAC;IACtB,CAAC;IAED;;;;OAIG;IAEH,IAAI,IAAI;QACP,OAAO,IAAI,CAAC,KAAK,CAAC;IACnB,CAAC;IAED;;OAEG;IAEI,QAAQ;QACd,OAAO,SACN,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,QAAQ,WACvC,IAAI,CAAC,MAAM,CAAC,IAAI,SAAS,CAAC;IAC5B,CAAC;CACD,CAAA;AAxEA;IADC,oBAAO;IACO,WAAA,oBAAO,CAAA;4CAMrB;AAaD;IADC,oBAAO;4CAGP;AA4BD;IADC,oBAAO;6CAGP;AAQD;IADC,oBAAO;0CAGP;AAMD;IADC,qBAAQ;8CAKR;AAjLW,cAAc;IAqCxB,WAAA,oBAAO,CAAA;IACP,WAAA,oBAAO,CAAA;IACP,WAAA,oBAAO,CAAA;GAvCG,cAAc,CAkL1B;AAlLY,wCAAc","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// CONVERSTION complete, Burt Harris 10/14/2016\nimport { MultiMap } from \"../../misc/MultiMap\";\nimport { NotNull, Override } from \"../../Decorators\";\nimport { ParseTree } from \"../ParseTree\";\nimport { ParseTreePattern } from \"./ParseTreePattern\";\n\n/**\n * Represents the result of matching a {@link ParseTree} against a tree pattern.\n */\nexport class ParseTreeMatch {\n\t/**\n\t * This is the backing field for `tree`.\n\t */\n\tprivate _tree: ParseTree;\n\n\t/**\n\t * This is the backing field for `pattern`.\n\t */\n\tprivate _pattern: ParseTreePattern;\n\n\t/**\n\t * This is the backing field for `labels`.\n\t */\n\tprivate _labels: MultiMap<string, ParseTree>;\n\n\t/**\n\t * This is the backing field for `mismatchedNode`.\n\t */\n\tprivate _mismatchedNode?: ParseTree;\n\n\t/**\n\t * Constructs a new instance of {@link ParseTreeMatch} from the specified\n\t * parse tree and pattern.\n\t *\n\t * @param tree The parse tree to match against the pattern.\n\t * @param pattern The parse tree pattern.\n\t * @param labels A mapping from label names to collections of\n\t * {@link ParseTree} objects located by the tree pattern matching process.\n\t * @param mismatchedNode The first node which failed to match the tree\n\t * pattern during the matching process.\n\t *\n\t * @throws {@link Error} if `tree` is not defined\n\t * @throws {@link Error} if `pattern` is not defined\n\t * @throws {@link Error} if `labels` is not defined\n\t */\n\tconstructor(\n\t\t@NotNull tree: ParseTree,\n\t\t@NotNull pattern: ParseTreePattern,\n\t\t@NotNull labels: MultiMap<string, ParseTree>,\n\t\tmismatchedNode: ParseTree | undefined) {\n\t\tif (!tree) {\n\t\t\tthrow new Error(\"tree cannot be null\");\n\t\t}\n\n\t\tif (!pattern) {\n\t\t\tthrow new Error(\"pattern cannot be null\");\n\t\t}\n\n\t\tif (!labels) {\n\t\t\tthrow new Error(\"labels cannot be null\");\n\t\t}\n\n\t\tthis._tree = tree;\n\t\tthis._pattern = pattern;\n\t\tthis._labels = labels;\n\t\tthis._mismatchedNode = mismatchedNode;\n\t}\n\n\t/**\n\t * Get the last node associated with a specific `label`.\n\t *\n\t * For example, for pattern `<id:ID>`, `get(\"id\")` returns the\n\t * node matched for that `ID`. If more than one node\n\t * matched the specified label, only the last is returned. If there is\n\t * no node associated with the label, this returns `undefined`.\n\t *\n\t * Pattern tags like `<ID>` and `<expr>` without labels are\n\t * considered to be labeled with `ID` and `expr`, respectively.\n\t *\n\t * @param label The label to check.\n\t *\n\t * @returns The last {@link ParseTree} to match a tag with the specified\n\t * label, or `undefined` if no parse tree matched a tag with the label.\n\t */\n\tpublic get(label: string): ParseTree | undefined {\n\t\tlet parseTrees = this._labels.get(label);\n\t\tif (!parseTrees || parseTrees.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn parseTrees[parseTrees.length - 1]; // return last if multiple\n\t}\n\n\t/**\n\t * Return all nodes matching a rule or token tag with the specified label.\n\t *\n\t * If the `label` is the name of a parser rule or token in the\n\t * grammar, the resulting list will contain both the parse trees matching\n\t * rule or tags explicitly labeled with the label and the complete set of\n\t * parse trees matching the labeled and unlabeled tags in the pattern for\n\t * the parser rule or token. For example, if `label` is `\"foo\"`,\n\t * the result will contain *all* of the following.\n\t *\n\t * * Parse tree nodes matching tags of the form `<foo:anyRuleName>` and\n\t *   `<foo:AnyTokenName>`.\n\t * * Parse tree nodes matching tags of the form `<anyLabel:foo>`.\n\t * * Parse tree nodes matching tags of the form `<foo>`.\n\t *\n\t * @param label The label.\n\t *\n\t * @returns A collection of all {@link ParseTree} nodes matching tags with\n\t * the specified `label`. If no nodes matched the label, an empty list\n\t * is returned.\n\t */\n\t@NotNull\n\tpublic getAll(@NotNull label: string): ParseTree[] {\n\t\tconst nodes = this._labels.get(label);\n\t\tif (!nodes) {\n\t\t\treturn [];\n\t\t}\n\t\treturn nodes;\n\t}\n\n\t/**\n\t * Return a mapping from label &rarr; [list of nodes].\n\t *\n\t * The map includes special entries corresponding to the names of rules and\n\t * tokens referenced in tags in the original pattern. For additional\n\t * information, see the description of {@link #getAll(String)}.\n\t *\n\t * @returns A mapping from labels to parse tree nodes. If the parse tree\n\t * pattern did not contain any rule or token tags, this map will be empty.\n\t */\n\t@NotNull\n\tget labels(): MultiMap<string, ParseTree> {\n\t\treturn this._labels;\n\t}\n\n\t/**\n\t * Get the node at which we first detected a mismatch.\n\t *\n\t * @returns the node at which we first detected a mismatch, or `undefined`\n\t * if the match was successful.\n\t */\n\tget mismatchedNode(): ParseTree | undefined {\n\t\treturn this._mismatchedNode;\n\t}\n\n\t/**\n\t * Gets a value indicating whether the match operation succeeded.\n\t *\n\t * @returns `true` if the match operation succeeded; otherwise,\n\t * `false`.\n\t */\n\tget succeeded(): boolean {\n\t\treturn !this._mismatchedNode;\n\t}\n\n\t/**\n\t * Get the tree pattern we are matching against.\n\t *\n\t * @returns The tree pattern we are matching against.\n\t */\n\t@NotNull\n\tget pattern(): ParseTreePattern {\n\t\treturn this._pattern;\n\t}\n\n\t/**\n\t * Get the parse tree we are trying to match to a pattern.\n\t *\n\t * @returns The {@link ParseTree} we are trying to match to a pattern.\n\t */\n\t@NotNull\n\tget tree(): ParseTree {\n\t\treturn this._tree;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic toString(): string {\n\t\treturn `Match ${\n\t\t\tthis.succeeded ? \"succeeded\" : \"failed\"}; found ${\n\t\t\tthis.labels.size} labels`;\n\t}\n}\n"]}