{"version":3,"file":"ParseTreePattern.js","sourceRoot":"","sources":["../../../../src/tree/pattern/ParseTreePattern.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;;;;AAEH,+CAA+C;AAC/C,iDAA2C;AAI3C,0CAAuC;AAEvC;;;GAGG;AACH,IAAa,gBAAgB,GAA7B;IAwBC;;;;;;;;;OASG;IACH,YACU,OAAgC,EAChC,OAAe,EACxB,gBAAwB,EACf,WAAsB;QAC/B,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,iBAAiB,GAAG,gBAAgB,CAAC;QAC1C,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;QACxB,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;IACjC,CAAC;IAED;;;;;;;OAOG;IAEI,KAAK,CAAU,IAAe;QACpC,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;IACxC,CAAC;IAED;;;;;;OAMG;IACI,OAAO,CAAU,IAAe;QACtC,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,SAAS,CAAC;IAClD,CAAC;IAED;;;;;;;;;;OAUG;IAEI,OAAO,CAAU,IAAe,EAAW,KAAa;QAC9D,IAAI,QAAQ,GAAmB,aAAK,CAAC,OAAO,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QAChF,IAAI,OAAO,GAAqB,EAAE,CAAC;QACnC,KAAK,IAAI,CAAC,IAAI,QAAQ,EAAE;YACvB,IAAI,KAAK,GAAmB,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;YAC1C,IAAI,KAAK,CAAC,SAAS,EAAE;gBACpB,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;aACpB;SACD;QACD,OAAO,OAAO,CAAC;IAChB,CAAC;IAED;;;;;OAKG;IAEH,IAAI,OAAO;QACV,OAAO,IAAI,CAAC,QAAQ,CAAC;IACtB,CAAC;IAED;;;;OAIG;IAEH,IAAI,OAAO;QACV,OAAO,IAAI,CAAC,QAAQ,CAAC;IACtB,CAAC;IAED;;;;;;OAMG;IACH,IAAI,gBAAgB;QACnB,OAAO,IAAI,CAAC,iBAAiB,CAAC;IAC/B,CAAC;IAED;;;;;;OAMG;IAEH,IAAI,WAAW;QACd,OAAO,IAAI,CAAC,YAAY,CAAC;IAC1B,CAAC;CACD,CAAA;AA9HA;IADC,oBAAO;kDACiB;AAMzB;IADC,oBAAO;sDACwB;AAMhC;IADC,oBAAO;kDACkC;AAgC1C;IADC,oBAAO;IACM,WAAA,oBAAO,CAAA;6CAEpB;AASD;IAAgB,WAAA,oBAAO,CAAA;+CAEtB;AAcD;IADC,oBAAO;IACQ,WAAA,oBAAO,CAAA,EAAmB,WAAA,oBAAO,CAAA;+CAUhD;AASD;IADC,oBAAO;+CAGP;AAQD;IADC,oBAAO;+CAGP;AAqBD;IADC,oBAAO;mDAGP;AAvIW,gBAAgB;IAmC1B,WAAA,oBAAO,CAAA;IACP,WAAA,oBAAO,CAAA;IAEP,WAAA,oBAAO,CAAA;GAtCG,gBAAgB,CAwI5B;AAxIY,4CAAgB","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// CONVERSTION complete, Burt Harris 10/14/2016\nimport { NotNull } from \"../../Decorators\";\nimport { ParseTree } from \"../ParseTree\";\nimport { ParseTreeMatch } from \"./ParseTreeMatch\";\nimport { ParseTreePatternMatcher } from \"./ParseTreePatternMatcher\";\nimport { XPath } from \"../xpath/XPath\";\n\n/**\n * A pattern like `<ID> = <expr>;` converted to a {@link ParseTree} by\n * {@link ParseTreePatternMatcher#compile(String, int)}.\n */\nexport class ParseTreePattern {\n\t/**\n\t * This is the backing field for `patternRuleIndex`.\n\t */\n\tprivate _patternRuleIndex: number;\n\n\t/**\n\t * This is the backing field for `pattern`.\n\t */\n\t@NotNull\n\tprivate _pattern: string;\n\n\t/**\n\t * This is the backing field for `patternTree`.\n\t */\n\t@NotNull\n\tprivate _patternTree: ParseTree;\n\n\t/**\n\t * This is the backing field for `matcher`.\n\t */\n\t@NotNull\n\tprivate _matcher: ParseTreePatternMatcher;\n\n\t/**\n\t * Construct a new instance of the {@link ParseTreePattern} class.\n\t *\n\t * @param matcher The {@link ParseTreePatternMatcher} which created this\n\t * tree pattern.\n\t * @param pattern The tree pattern in concrete syntax form.\n\t * @param patternRuleIndex The parser rule which serves as the root of the\n\t * tree pattern.\n\t * @param patternTree The tree pattern in {@link ParseTree} form.\n\t */\n\tconstructor(\n\t\t@NotNull matcher: ParseTreePatternMatcher,\n\t\t@NotNull pattern: string,\n\t\tpatternRuleIndex: number,\n\t\t@NotNull patternTree: ParseTree) {\n\t\tthis._matcher = matcher;\n\t\tthis._patternRuleIndex = patternRuleIndex;\n\t\tthis._pattern = pattern;\n\t\tthis._patternTree = patternTree;\n\t}\n\n\t/**\n\t * Match a specific parse tree against this tree pattern.\n\t *\n\t * @param tree The parse tree to match against this tree pattern.\n\t * @returns A {@link ParseTreeMatch} object describing the result of the\n\t * match operation. The `ParseTreeMatch.succeeded` method can be\n\t * used to determine whether or not the match was successful.\n\t */\n\t@NotNull\n\tpublic match(@NotNull tree: ParseTree): ParseTreeMatch {\n\t\treturn this._matcher.match(tree, this);\n\t}\n\n\t/**\n\t * Determine whether or not a parse tree matches this tree pattern.\n\t *\n\t * @param tree The parse tree to match against this tree pattern.\n\t * @returns `true` if `tree` is a match for the current tree\n\t * pattern; otherwise, `false`.\n\t */\n\tpublic matches(@NotNull tree: ParseTree): boolean {\n\t\treturn this._matcher.match(tree, this).succeeded;\n\t}\n\n\t/**\n\t * Find all nodes using XPath and then try to match those subtrees against\n\t * this tree pattern.\n\t *\n\t * @param tree The {@link ParseTree} to match against this pattern.\n\t * @param xpath An expression matching the nodes\n\t *\n\t * @returns A collection of {@link ParseTreeMatch} objects describing the\n\t * successful matches. Unsuccessful matches are omitted from the result,\n\t * regardless of the reason for the failure.\n\t */\n\t@NotNull\n\tpublic findAll(@NotNull tree: ParseTree, @NotNull xpath: string): ParseTreeMatch[] {\n\t\tlet subtrees: Set<ParseTree> = XPath.findAll(tree, xpath, this._matcher.parser);\n\t\tlet matches: ParseTreeMatch[] = [];\n\t\tfor (let t of subtrees) {\n\t\t\tlet match: ParseTreeMatch = this.match(t);\n\t\t\tif (match.succeeded) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t}\n\t\treturn matches;\n\t}\n\n\t/**\n\t * Get the {@link ParseTreePatternMatcher} which created this tree pattern.\n\t *\n\t * @returns The {@link ParseTreePatternMatcher} which created this tree\n\t * pattern.\n\t */\n\t@NotNull\n\tget matcher(): ParseTreePatternMatcher {\n\t\treturn this._matcher;\n\t}\n\n\t/**\n\t * Get the tree pattern in concrete syntax form.\n\t *\n\t * @returns The tree pattern in concrete syntax form.\n\t */\n\t@NotNull\n\tget pattern(): string {\n\t\treturn this._pattern;\n\t}\n\n\t/**\n\t * Get the parser rule which serves as the outermost rule for the tree\n\t * pattern.\n\t *\n\t * @returns The parser rule which serves as the outermost rule for the tree\n\t * pattern.\n\t */\n\tget patternRuleIndex(): number {\n\t\treturn this._patternRuleIndex;\n\t}\n\n\t/**\n\t * Get the tree pattern as a {@link ParseTree}. The rule and token tags from\n\t * the pattern are present in the parse tree as terminal nodes with a symbol\n\t * of type {@link RuleTagToken} or {@link TokenTagToken}.\n\t *\n\t * @returns The tree pattern as a {@link ParseTree}.\n\t */\n\t@NotNull\n\tget patternTree(): ParseTree {\n\t\treturn this._patternTree;\n\t}\n}\n"]}