{"version":3,"file":"RuleTagToken.js","sourceRoot":"","sources":["../../../../src/tree/pattern/RuleTagToken.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;;;;;;;;;AAKH,iDAAqD;AACrD,uCAAoC;AAGpC;;;;GAIG;AACH,IAAa,YAAY,GAAzB;IAeC;;;;;;;;;;;OAWG;IACH,YAAqB,QAAgB,EAAE,eAAuB,EAAE,KAAc;QAC7E,IAAI,QAAQ,IAAI,IAAI,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;YAC9C,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC;SACrD;QAED,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC;QAC1B,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;QACvC,IAAI,CAAC,MAAM,GAAG,KAAK,CAAC;IACrB,CAAC;IAED;;;;OAIG;IAEH,IAAI,QAAQ;QACX,OAAO,IAAI,CAAC,SAAS,CAAC;IACvB,CAAC;IAED;;;;;OAKG;IACH,IAAI,KAAK;QACR,OAAO,IAAI,CAAC,MAAM,CAAC;IACpB,CAAC;IAED;;;;OAIG;IAEH,IAAI,OAAO;QACV,OAAO,aAAK,CAAC,eAAe,CAAC;IAC9B,CAAC;IAED;;;;;OAKG;IAEH,IAAI,IAAI;QACP,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,EAAE;YACxB,OAAO,GAAG,GAAG,IAAI,CAAC,MAAM,GAAG,GAAG,GAAG,IAAI,CAAC,SAAS,GAAG,GAAG,CAAC;SACtD;QAED,OAAO,GAAG,GAAG,IAAI,CAAC,SAAS,GAAG,GAAG,CAAC;IACnC,CAAC;IAED;;;;;OAKG;IAEH,IAAI,IAAI;QACP,OAAO,IAAI,CAAC,eAAe,CAAC;IAC7B,CAAC;IAED;;;;OAIG;IAEH,IAAI,IAAI;QACP,OAAO,CAAC,CAAC;IACV,CAAC;IAED;;;;OAIG;IAEH,IAAI,kBAAkB;QACrB,OAAO,CAAC,CAAC,CAAC;IACX,CAAC;IAED;;;;OAIG;IAEH,IAAI,UAAU;QACb,OAAO,CAAC,CAAC,CAAC;IACX,CAAC;IAED;;;;OAIG;IAEH,IAAI,UAAU;QACb,OAAO,CAAC,CAAC,CAAC;IACX,CAAC;IAED;;;;OAIG;IAEH,IAAI,SAAS;QACZ,OAAO,CAAC,CAAC,CAAC;IACX,CAAC;IAED;;;;OAIG;IAEH,IAAI,WAAW;QACd,OAAO,SAAS,CAAC;IAClB,CAAC;IAED;;;;OAIG;IAEH,IAAI,WAAW;QACd,OAAO,SAAS,CAAC;IAClB,CAAC;IAED;;;;;OAKG;IAEI,QAAQ;QACd,OAAO,IAAI,CAAC,SAAS,GAAG,GAAG,GAAG,IAAI,CAAC,eAAe,CAAC;IACpD,CAAC;CACD,CAAA;AAlIA;IADC,oBAAO;4CAGP;AAkBD;IADC,qBAAQ;2CAGR;AASD;IADC,qBAAQ;wCAOR;AASD;IADC,qBAAQ;wCAGR;AAQD;IADC,qBAAQ;wCAGR;AAQD;IADC,qBAAQ;sDAGR;AAQD;IADC,qBAAQ;8CAGR;AAQD;IADC,qBAAQ;8CAGR;AAQD;IADC,qBAAQ;6CAGR;AAQD;IADC,qBAAQ;+CAGR;AAQD;IADC,qBAAQ;+CAGR;AASD;IADC,qBAAQ;4CAGR;AA5KW,YAAY;IA2BX,WAAA,oBAAO,CAAA;GA3BR,YAAY,CA6KxB;AA7KY,oCAAY","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:46.0343500-07:00\n\nimport { CharStream } from \"../../CharStream\";\nimport { NotNull, Override } from \"../../Decorators\";\nimport { Token } from \"../../Token\";\nimport { TokenSource } from \"../../TokenSource\";\n\n/**\n * A {@link Token} object representing an entire subtree matched by a parser\n * rule; e.g., `<expr>`. These tokens are created for {@link TagChunk}\n * chunks where the tag corresponds to a parser rule.\n */\nexport class RuleTagToken implements Token {\n\t/**\n\t * This is the backing field for `ruleName`.\n\t */\n\tprivate _ruleName: string;\n\t/**\n\t * The token type for the current token. This is the token type assigned to\n\t * the bypass alternative for the rule during ATN deserialization.\n\t */\n\tprivate bypassTokenType: number;\n\t/**\n\t * This is the backing field for `label`.\n\t */\n\tprivate _label?: string;\n\n\t/**\n\t * Constructs a new instance of {@link RuleTagToken} with the specified rule\n\t * name, bypass token type, and label.\n\t *\n\t * @param ruleName The name of the parser rule this rule tag matches.\n\t * @param bypassTokenType The bypass token type assigned to the parser rule.\n\t * @param label The label associated with the rule tag, or `undefined` if\n\t * the rule tag is unlabeled.\n\t *\n\t * @exception IllegalArgumentException if `ruleName` is not defined\n\t * or empty.\n\t */\n\tconstructor(@NotNull ruleName: string, bypassTokenType: number, label?: string) {\n\t\tif (ruleName == null || ruleName.length === 0) {\n\t\t\tthrow new Error(\"ruleName cannot be null or empty.\");\n\t\t}\n\n\t\tthis._ruleName = ruleName;\n\t\tthis.bypassTokenType = bypassTokenType;\n\t\tthis._label = label;\n\t}\n\n\t/**\n\t * Gets the name of the rule associated with this rule tag.\n\t *\n\t * @returns The name of the parser rule associated with this rule tag.\n\t */\n\t@NotNull\n\tget ruleName(): string {\n\t\treturn this._ruleName;\n\t}\n\n\t/**\n\t * Gets the label associated with the rule tag.\n\t *\n\t * @returns The name of the label associated with the rule tag, or\n\t * `undefined` if this is an unlabeled rule tag.\n\t */\n\tget label(): string | undefined {\n\t\treturn this._label;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * Rule tag tokens are always placed on the {@link #DEFAULT_CHANNEL}.\n\t */\n\t@Override\n\tget channel(): number {\n\t\treturn Token.DEFAULT_CHANNEL;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * This method returns the rule tag formatted with `<` and `>`\n\t * delimiters.\n\t */\n\t@Override\n\tget text(): string {\n\t\tif (this._label != null) {\n\t\t\treturn \"<\" + this._label + \":\" + this._ruleName + \">\";\n\t\t}\n\n\t\treturn \"<\" + this._ruleName + \">\";\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * Rule tag tokens have types assigned according to the rule bypass\n\t * transitions created during ATN deserialization.\n\t */\n\t@Override\n\tget type(): number {\n\t\treturn this.bypassTokenType;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The implementation for {@link RuleTagToken} always returns 0.\n\t */\n\t@Override\n\tget line(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The implementation for {@link RuleTagToken} always returns -1.\n\t */\n\t@Override\n\tget charPositionInLine(): number {\n\t\treturn -1;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The implementation for {@link RuleTagToken} always returns -1.\n\t */\n\t@Override\n\tget tokenIndex(): number {\n\t\treturn -1;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The implementation for {@link RuleTagToken} always returns -1.\n\t */\n\t@Override\n\tget startIndex(): number {\n\t\treturn -1;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The implementation for {@link RuleTagToken} always returns -1.\n\t */\n\t@Override\n\tget stopIndex(): number {\n\t\treturn -1;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The implementation for {@link RuleTagToken} always returns `undefined`.\n\t */\n\t@Override\n\tget tokenSource(): TokenSource | undefined {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The implementation for {@link RuleTagToken} always returns `undefined`.\n\t */\n\t@Override\n\tget inputStream(): CharStream | undefined {\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The implementation for {@link RuleTagToken} returns a string of the form\n\t * `ruleName:bypassTokenType`.\n\t */\n\t@Override\n\tpublic toString(): string {\n\t\treturn this._ruleName + \":\" + this.bypassTokenType;\n\t}\n}\n"]}