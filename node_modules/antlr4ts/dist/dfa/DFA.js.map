{"version":3,"file":"DFA.js","sourceRoot":"","sources":["../../../src/dfa/DFA.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:38.3567094-07:00\n\nimport { Array2DHashSet } from \"../misc/Array2DHashSet\";\nimport { ATN } from \"../atn/ATN\";\nimport { ATNConfigSet } from \"../atn/ATNConfigSet\";\nimport { ATNState } from \"../atn/ATNState\";\nimport { ATNType } from \"../atn/ATNType\";\nimport { DecisionState } from \"../atn/DecisionState\";\nimport { DFASerializer } from \"./DFASerializer\";\nimport { DFAState } from \"./DFAState\";\nimport { LexerATNSimulator } from \"../atn/LexerATNSimulator\";\nimport { LexerDFASerializer } from \"./LexerDFASerializer\";\nimport { NotNull } from \"../Decorators\";\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\nimport { StarLoopEntryState } from \"../atn/StarLoopEntryState\";\nimport { Token } from \"../Token\";\nimport { TokensStartState } from \"../atn/TokensStartState\";\nimport { Vocabulary } from \"../Vocabulary\";\nimport { VocabularyImpl } from \"../VocabularyImpl\";\n\nexport class DFA {\n\t/**\n\t * A set of all states in the `DFA`.\n\t *\n\t * Note that this collection of states holds the DFA states for both SLL and LL prediction. Only the start state\n\t * needs to be differentiated for these cases, which is tracked by the `s0` and `s0full` fields.\n\t */\n\t@NotNull\n\tpublic readonly states: Array2DHashSet<DFAState> = new Array2DHashSet<DFAState>(ObjectEqualityComparator.INSTANCE);\n\n\tpublic s0: DFAState | undefined;\n\n\tpublic s0full: DFAState | undefined;\n\n\tpublic readonly decision: number;\n\n\t/** From which ATN state did we create this DFA? */\n\t@NotNull\n\tpublic atnStartState: ATNState;\n\t/**\n\t * Note: this field is accessed as `atnStartState.atn` in other targets. The TypeScript target keeps a separate copy\n\t * to avoid a number of additional null/undefined checks each time the ATN is accessed.\n\t */\n\t@NotNull\n\tpublic atn: ATN;\n\n\tprivate nextStateNumber: number = 0;\n\n\t/**\n\t * `true` if this DFA is for a precedence decision; otherwise,\n\t * `false`. This is the backing field for {@link #isPrecedenceDfa}.\n\t */\n\tprivate precedenceDfa: boolean;\n\n\t/**\n\t * Constructs a `DFA` instance associated with a lexer mode.\n\t *\n\t * The start state for a `DFA` constructed with this constructor should be a `TokensStartState`, which is the start\n\t * state for a lexer mode. The prediction made by this DFA determines the lexer rule which matches the current\n\t * input.\n\t *\n\t * @param atnStartState The start state for the mode.\n\t */\n\tconstructor(atnStartState: TokensStartState);\n\t/**\n\t * Constructs a `DFA` instance associated with a decision.\n\t *\n\t * @param atnStartState The decision associated with this DFA.\n\t * @param decision The decision number.\n\t */\n\tconstructor(atnStartState: DecisionState, decision: number);\n\tconstructor(@NotNull atnStartState: ATNState, decision: number = 0) {\n\t\tif (!atnStartState.atn) {\n\t\t\tthrow new Error(\"The ATNState must be associated with an ATN\");\n\t\t}\n\n\t\tthis.atnStartState = atnStartState;\n\t\tthis.atn = atnStartState.atn;\n\t\tthis.decision = decision;\n\n\t\t// Precedence DFAs are associated with the special precedence decision created for left-recursive rules which\n\t\t// evaluate their alternatives using a precedence hierarchy. When such a decision is encountered, we mark this\n\t\t// DFA instance as a precedence DFA and initialize the initial states s0 and s0full to special DFAState\n\t\t// instances which use outgoing edges to link to the actual start state used for each precedence level.\n\t\tlet isPrecedenceDfa: boolean = false;\n\t\tif (atnStartState instanceof StarLoopEntryState) {\n\t\t\tif (atnStartState.precedenceRuleDecision) {\n\t\t\t\tisPrecedenceDfa = true;\n\t\t\t\tthis.s0 = new DFAState(new ATNConfigSet());\n\t\t\t\tthis.s0full = new DFAState(new ATNConfigSet());\n\t\t\t}\n\t\t}\n\n\t\tthis.precedenceDfa = isPrecedenceDfa;\n\t}\n\n\t/**\n\t * Gets whether this DFA is a precedence DFA. Precedence DFAs use a special\n\t * start state {@link #s0} which is not stored in {@link #states}. The\n\t * {@link DFAState#edges} array for this start state contains outgoing edges\n\t * supplying individual start states corresponding to specific precedence\n\t * values.\n\t *\n\t * @returns `true` if this is a precedence DFA; otherwise,\n\t * `false`.\n\t * @see Parser.precedence\n\t */\n\tget isPrecedenceDfa(): boolean {\n\t\treturn this.precedenceDfa;\n\t}\n\n\t/**\n\t * Get the start state for a specific precedence value.\n\t *\n\t * @param precedence The current precedence.\n\t * @returns The start state corresponding to the specified precedence, or\n\t * `undefined` if no start state exists for the specified precedence.\n\t *\n\t * @ if this is not a precedence DFA.\n\t * @see `isPrecedenceDfa`\n\t */\n\tpublic getPrecedenceStartState(precedence: number, fullContext: boolean): DFAState | undefined {\n\t\tif (!this.isPrecedenceDfa) {\n\t\t\tthrow new Error(\"Only precedence DFAs may contain a precedence start state.\");\n\t\t}\n\n\t\t// s0 and s0full are never null for a precedence DFA\n\t\tif (fullContext) {\n\t\t\treturn (this.s0full as DFAState).getTarget(precedence);\n\t\t}\n\t\telse {\n\t\t\treturn (this.s0 as DFAState).getTarget(precedence);\n\t\t}\n\t}\n\n\t/**\n\t * Set the start state for a specific precedence value.\n\t *\n\t * @param precedence The current precedence.\n\t * @param startState The start state corresponding to the specified\n\t * precedence.\n\t *\n\t * @ if this is not a precedence DFA.\n\t * @see `isPrecedenceDfa`\n\t */\n\tpublic setPrecedenceStartState(precedence: number, fullContext: boolean, startState: DFAState): void {\n\t\tif (!this.isPrecedenceDfa) {\n\t\t\tthrow new Error(\"Only precedence DFAs may contain a precedence start state.\");\n\t\t}\n\n\t\tif (precedence < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (fullContext) {\n\t\t\t// s0full is never null for a precedence DFA\n\t\t\t(this.s0full as DFAState).setTarget(precedence, startState);\n\t\t}\n\t\telse {\n\t\t\t// s0 is never null for a precedence DFA\n\t\t\t(this.s0 as DFAState).setTarget(precedence, startState);\n\t\t}\n\t}\n\n\tget isEmpty(): boolean {\n\t\tif (this.isPrecedenceDfa) {\n\t\t\t// s0 and s0full are never null for a precedence DFA\n\t\t\treturn this.s0!.getEdgeMap().size === 0 && this.s0full!.getEdgeMap().size === 0;\n\t\t}\n\n\t\treturn this.s0 == null && this.s0full == null;\n\t}\n\n\tget isContextSensitive(): boolean {\n\t\tif (this.isPrecedenceDfa) {\n\t\t\t// s0full is never null for a precedence DFA\n\t\t\treturn (this.s0full as DFAState).getEdgeMap().size > 0;\n\t\t}\n\n\t\treturn this.s0full != null;\n\t}\n\n\tpublic addState(state: DFAState): DFAState {\n\t\tstate.stateNumber = this.nextStateNumber++;\n\t\treturn this.states.getOrAdd(state);\n\t}\n\n\tpublic toString(): string;\n\tpublic toString(/*@NotNull*/ vocabulary: Vocabulary): string;\n\tpublic toString(/*@NotNull*/ vocabulary: Vocabulary, ruleNames: string[] | undefined): string;\n\tpublic toString(vocabulary?: Vocabulary, ruleNames?: string[]): string {\n\t\tif (!vocabulary) {\n\t\t\tvocabulary = VocabularyImpl.EMPTY_VOCABULARY;\n\t\t}\n\n\t\tif (!this.s0) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tlet serializer: DFASerializer;\n\t\tif (ruleNames) {\n\t\t\tserializer = new DFASerializer(this, vocabulary, ruleNames, this.atnStartState.atn);\n\t\t} else {\n\t\t\tserializer = new DFASerializer(this, vocabulary);\n\t\t}\n\n\t\treturn serializer.toString();\n\t}\n\n\tpublic toLexerString(): string {\n\t\tif (!this.s0) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tlet serializer: DFASerializer = new LexerDFASerializer(this);\n\t\treturn serializer.toString();\n\t}\n}\n"]}