{"version":3,"file":"ANTLRInputStream.js","sourceRoot":"","sources":["../../src/ANTLRInputStream.ts"],"names":[],"mappings":"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","sourcesContent":["/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n// ConvertTo-TS run at 2016-10-04T11:26:49.0828748-07:00\n\nimport * as assert from \"assert\";\nimport { CharStream } from \"./CharStream\";\nimport { Arrays } from \"./misc/Arrays\";\nimport { Override } from \"./Decorators\";\nimport { IntStream } from \"./IntStream\";\nimport { Interval } from \"./misc/Interval\";\n\nconst READ_BUFFER_SIZE: number = 1024;\nconst INITIAL_BUFFER_SIZE: number = 1024;\n\n/**\n * Vacuum all input from a {@link Reader}/{@link InputStream} and then treat it\n * like a `char[]` buffer. Can also pass in a {@link String} or\n * `char[]` to use.\n *\n * If you need encoding, pass in stream/reader with correct encoding.\n *\n * @deprecated as of 4.7, please use `CharStreams` interface.\n */\nexport class ANTLRInputStream implements CharStream {\n\t/** The data being scanned */\n\tprotected data: string;\n\n\t/** How many characters are actually in the buffer */\n\tprotected n: number;\n\n\t/** 0..n-1 index into string of next char */\n\tprotected p: number = 0;\n\n\t/** What is name or source of this char stream? */\n\tpublic name?: string;\n\n\t/** Copy data in string to a local char array */\n\tconstructor(input: string) {\n\t\tthis.data = input;\n\t\tthis.n = input.length;\n\t}\n\n\t/** Reset the stream so that it's in the same state it was\n\t *  when the object was created *except* the data array is not\n\t *  touched.\n\t */\n\tpublic reset(): void {\n\t\tthis.p = 0;\n\t}\n\n\t@Override\n\tpublic consume(): void {\n\t\tif (this.p >= this.n) {\n\t\t\tassert(this.LA(1) === IntStream.EOF);\n\t\t\tthrow new Error(\"cannot consume EOF\");\n\t\t}\n\n\t\t//System.out.println(\"prev p=\"+p+\", c=\"+(char)data[p]);\n\t\tif (this.p < this.n) {\n\t\t\tthis.p++;\n\t\t\t//System.out.println(\"p moves to \"+p+\" (c='\"+(char)data[p]+\"')\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic LA(i: number): number {\n\t\tif (i === 0) {\n\t\t\treturn 0; // undefined\n\t\t}\n\t\tif (i < 0) {\n\t\t\ti++; // e.g., translate LA(-1) to use offset i=0; then data[p+0-1]\n\t\t\tif ((this.p + i - 1) < 0) {\n\t\t\t\treturn IntStream.EOF; // invalid; no char before first char\n\t\t\t}\n\t\t}\n\n\t\tif ((this.p + i - 1) >= this.n) {\n\t\t\t//System.out.println(\"char LA(\"+i+\")=EOF; p=\"+p);\n\t\t\treturn IntStream.EOF;\n\t\t}\n\t\t//System.out.println(\"char LA(\"+i+\")=\"+(char)data[p+i-1]+\"; p=\"+p);\n\t\t//System.out.println(\"LA(\"+i+\"); p=\"+p+\" n=\"+n+\" data.length=\"+data.length);\n\t\treturn this.data.charCodeAt(this.p + i - 1);\n\t}\n\n\tpublic LT(i: number): number {\n\t\treturn this.LA(i);\n\t}\n\n\t/** Return the current input symbol index 0..n where n indicates the\n\t *  last symbol has been read.  The index is the index of char to\n\t *  be returned from LA(1).\n\t */\n\t@Override\n\tget index(): number {\n\t\treturn this.p;\n\t}\n\n\t@Override\n\tget size(): number {\n\t\treturn this.n;\n\t}\n\n\t/** mark/release do nothing; we have entire buffer */\n\t@Override\n\tpublic mark(): number {\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic release(marker: number): void {\n\t\t// No default implementation since this stream buffers the entire input\n\t}\n\n\t/** consume() ahead until p==index; can't just set p=index as we must\n\t *  update line and charPositionInLine. If we seek backwards, just set p\n\t */\n\t@Override\n\tpublic seek(index: number): void {\n\t\tif (index <= this.p) {\n\t\t\tthis.p = index; // just jump; don't update stream state (line, ...)\n\t\t\treturn;\n\t\t}\n\t\t// seek forward, consume until p hits index or n (whichever comes first)\n\t\tindex = Math.min(index, this.n);\n\t\twhile (this.p < index) {\n\t\t\tthis.consume();\n\t\t}\n\t}\n\n\t@Override\n\tpublic getText(interval: Interval): string {\n\t\tlet start: number = interval.a;\n\t\tlet stop: number = interval.b;\n\t\tif (stop >= this.n) {\n\t\t\tstop = this.n - 1;\n\t\t}\n\t\tlet count: number = stop - start + 1;\n\t\tif (start >= this.n) {\n\t\t\treturn \"\";\n\t\t}\n\t\t// System.err.println(\"data: \"+Arrays.toString(data)+\", n=\"+n+\n\t\t// \t\t\t\t   \", start=\"+start+\n\t\t// \t\t\t\t   \", stop=\"+stop);\n\t\treturn this.data.substr(start, count);\n\t}\n\n\t@Override\n\tget sourceName(): string {\n\t\tif (!this.name) {\n\t\t\treturn IntStream.UNKNOWN_SOURCE_NAME;\n\t\t}\n\t\treturn this.name;\n\t}\n\n\t@Override\n\tpublic toString() { return this.data; }\n}\n"]}